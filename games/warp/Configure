#! /bin/sh
#
# Revision:
#  Removed unsigned long declarations from random number tester,
#  8/26/87, for pdp-11's and the 2.10 release.  Also fixed bug with
#  grep and the search for '-i' using $contains, and changed the man
#  directory for the search to /usr/man/man1.  Then fixed the man
#  installation suffix to be .6 if necessary.
#
# If these # comments don't work, trim them.  Don't worry about any other
# shell scripts, Configure will trim # comments from them for you.
#
# (If you are trying to port this package to a machine without sh, I would
# suggest you cut out the prototypical config.h from the end of Configure
# and edit it to reflect your system.  Some packages may include samples
# of config.h for certain machines, so you might look for one of those.)
#
# $Header: Configure,v 1.1 87/08/26 03:37:30 cr Exp $
#
# Yes, you may rip this off to use in other distribution packages.
# (Note: this Configure script was generated automatically.  Rather than
# working with this copy of Configure, you may wish to get metaconfig.)

: sanity checks
PATH='.:/bin:/usr/bin:/usr/local/bin:/usr/ucb:/usr/local:/usr/lbin:/etc'
export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh $0; kill $$)

if test ! -t 0; then
    echo "Say 'sh Configure', not 'sh <Configure'"
    exit 1
fi

(alias) >/dev/null 2>&1 && \
    echo "(I see you are using the Korn shell.  Some ksh's blow up on Configure," && \
    echo "especially on exotic machines.  If yours does, try the Bourne shell instead.)"

if test ! -d ../UU; then
    if test ! -d UU; then
	mkdir UU
    fi
    cd UU
fi

d_eunice=''
eunicefix=''
define=''
loclist=''
expr=''
sed=''
echo=''
cat=''
rm=''
mv=''
cp=''
tail=''
tr=''
mkdir=''
sort=''
uniq=''
grep=''
trylist=''
test=''
inews=''
egrep=''
more=''
pg=''
Mcc=''
vi=''
mailx=''
mail=''
Log=''
Header=''
cc=''
contains=''
cpp=''
d_charsprf=''
d_fcntl=''
d_ftime=''
d_gethname=''
d_douname=''
d_phostname=''
d_getpwent=''
d_havetlib=''
termlib=''
d_index=''
d_ioctl=''
d_normsig=''
jobslib=''
d_portable=''
d_rdchk=''
d_scorfl=''
d_sgndchr=''
d_termio=''
d_usendir=''
d_libndir=''
ndirc=''
ndiro=''
d_whoami=''
hostname=''
phostname=''
mydomain=''
libc=''
libnm=''
mansrc=''
models=''
split=''
small=''
medium=''
large=''
huge=''
ccflags=''
ldflags=''
n=''
c=''
nametype=''
d_passnames=''
d_berknames=''
d_usgnames=''
passcat=''
package=''
prefshell=''
randbits=''
registers=''
reg1=''
reg2=''
reg3=''
reg4=''
reg5=''
reg6=''
reg7=''
reg8=''
reg9=''
reg10=''
reg11=''
reg12=''
reg13=''
reg14=''
reg15=''
reg16=''
rootid=''
spitshell=''
shsharp=''
sharpbang=''
startsh=''
voidflags=''
bin=''
chowner=''
privlib=''
CONFIG=''

: set package name
package=warp

echo " "
echo "Beginning of configuration questions for $package kit."
: Eunice requires " " instead of "", can you believe it
echo " "

define='define'
undef='/*undef'
libpth='/usr/lib /usr/local/lib /lib'
smallmach='pdp11 i8086 z8000 i80286 iAPX286'
rmlist='kit[1-9]isdone kit[1-9][0-9]isdone'
trap 'echo " "; rm -f $rmlist; exit 1' 1 2 3
attrlist="mc68000 sun gcos unix ibm gimpel interdata tss os mert pyr"
attrlist="$attrlist vax pdp11 i8086 z8000 u3b2 u3b5 u3b20 u3b200"
attrlist="$attrlist ns32000 ns16000 iAPX286"
pth="/usr/ucb /bin /usr/bin /usr/local /usr/local/bin /usr/lbin /etc /usr/lib"
defvoidused=7

: some greps do not return status, grrr.
echo "grimblepritz" >grimble
if grep blurfldyick grimble >/dev/null 2>&1 ; then
    contains=contains
elif grep grimblepritz grimble >/dev/null 2>&1 ; then
    contains=grep
else
    contains=contains
fi
rm -f grimble
: the following should work in any shell
case "$contains" in
contains*)
    echo " "
    echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
    cat >contains <<'EOSS'
grep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
EOSS
chmod 755 contains
esac

: first determine how to suppress newline on echo command
echo "Checking echo to see how to suppress newlines..."
(echo "hi there\c" ; echo " ") >.echotmp
if $contains c .echotmp >/dev/null 2>&1 ; then
    echo "...using -n."
    n='-n'
    c=''
else
    cat <<'EOM'
...using \c
EOM
    n=''
    c='\c'
fi
echo $n "Type carriage return to continue.  Your cursor should be here-->$c"
read ans
rm -f .echotmp

: now set up to do reads with possible shell escape and default assignment
cat <<EOSC >myread
ans='!'
while expr "X\$ans" : "X!" >/dev/null; do
    read ans
    case "\$ans" in
    !)
	sh
	echo " "
	echo $n "\$rp $c"
	;;
    !*)
	set \`expr "X\$ans" : "X!\(.*\)\$"\`
	sh -c "\$*"
	echo " "
	echo $n "\$rp $c"
	;;
    esac
done
rp='Your answer:'
case "\$ans" in
'') ans="\$dflt";;
esac
EOSC

: general instructions
cat <<EOH
 
This installation shell script will examine your system and ask you questions
to determine how the $package package should be installed.  If you get stuck
on a question, you may use a ! shell escape to start a subshell or execute
a command.  Many of the questions will have default answers in square
brackets--typing carriage return will give you the default.

On some of the questions which ask for file or directory names you are
allowed to use the ~name construct to specify the login directory belonging
to "name", even if you don't have a shell which knows about that.  Questions
where this is allowed will be marked "(~name ok)".

EOH
rp="[Type carriage return to continue]"
echo $n "$rp $c"
. myread
cat <<EOH

Much effort has been expended to ensure that this shell script will run
on any Unix system.  If despite that it blows up on you, your best bet is
to edit Configure and run it again. Also, let me (lwall@sdcrdcf.UUCP) know
how I blew it.  If you can't run Configure for some reason, you'll have
to generate a config.sh file by hand.

This installation script affects things in two ways: 1) it may do direct
variable substitutions on some of the files included in this kit, and
2) it builds a config.h file for inclusion in C programs.  You may edit
any of these files as the need arises after running this script.

If you make a mistake on a question, there is no easy way to back up to it
currently.  The easiest thing to do is to edit config.sh and rerun all the
SH files.  Configure will offer to let you do this before it runs the SH files.

EOH
rp="[Type carriage return to continue]"
echo $n "$rp $c"
. myread

: get old answers, if there is a config file out there
if test -f ../config.sh; then
    echo " "
    dflt=y
    rp="I see a config.sh file.  Did Configure make it on THIS system? [$dflt]"
    echo $n "$rp $c"
    . myread
    case "$ans" in
    n*) echo "OK, I'll ignore it.";;
    *)  echo "Fetching default answers from your old config.sh file..."
	tmp="$n"
	ans="$c"
        . ../config.sh
	n="$tmp"
	c="$ans"
	;;
    esac
fi

: find out where common programs are
echo " "
echo "Locating common programs..."
cat <<EOSC >loc
$startsh
case \$# in
0) exit 1;;
esac
thing=\$1
shift
dflt=\$1
shift
for dir in \$*; do
    case "\$thing" in
    .)
	if test -d \$dir/\$thing; then
	    echo \$dir
	    exit 0
	fi
	;;
    *)
	if test -f \$dir/\$thing; then
	    echo \$dir/\$thing
	    exit 0
	fi
	;;
    esac
done
echo \$dflt
exit 1
EOSC
chmod 755 loc
$eunicefix loc
loclist="
expr
sed
echo
cat
rm
mv
cp
tr
mkdir
sort
uniq
grep
"
trylist="
test
egrep
Mcc
"
for file in $loclist; do
    xxx=`loc $file $file $pth`
    eval $file=$xxx
    eval _$file=$xxx
    case "$xxx" in
    /*)
	echo $file is in $xxx.
	;;
    *)
	echo "I don't know where $file is.  I hope it's in everyone's PATH."
	;;
    esac
done
echo " "
echo "Don't worry if any of the following aren't found..."
ans=offhand
for file in $trylist; do
    xxx=`loc $file $file $pth`
    eval $file=$xxx
    eval _$file=$xxx
    case "$xxx" in
    /*)
	echo $file is in $xxx.
	;;
    *)
	echo "I don't see $file out there, $ans."
	ans=either
	;;
    esac
done
case "$egrep" in
egrep)
    echo "Substituting grep for egrep."
    egrep=$grep
    ;;
esac
case "$test" in
test)
    echo "Hopefully test is built into your sh."
    ;;
/bin/test)
    echo " "
    dflt=n
    rp="Is your "'"'"test"'"'" built into sh? [$dflt] (OK to guess)"
    echo $n "$rp $c"
    . myread
    case "$ans" in
    y*) test=test ;;
    esac
    ;;
*)
    test=test
    ;;
esac
case "$echo" in
echo)
    echo "Hopefully echo is built into your sh."
    ;;
/bin/echo)
    echo " "
    echo "Checking compatibility between /bin/echo and builtin echo (if any)..."
    $echo $n "hi there$c" >foo1
    echo $n "hi there$c" >foo2
    if cmp foo1 foo2 >/dev/null 2>&1; then
	echo "They are compatible.  In fact, they may be identical."
    else
	case "$n" in
	'-n') n='' c='\c' ans='\c' ;;
	*) n='-n' c='' ans='-n' ;;
	esac
	cat <<FOO
They are not compatible!  You are probably running ksh on a non-USG system.
I'll have to use /bin/echo instead of the builtin, since Bourne shell doesn't
have echo built in and we may have to run some Bourne shell scripts.  That
means I'll have to use $ans to suppress newlines now.  Life is ridiculous.

FOO
	rp="Your cursor should be here-->"
	$echo $n "$rp$c"
	. myread
    fi
    $rm -f foo1 foo2
    ;;
*)
    : cross your fingers
    echo=echo
    ;;
esac
rmlist="$rmlist loc"

: get list of predefined functions in a handy place
echo " "
if test -f /lib/libc.a; then
    echo "Your C library is in /lib/libc.a.  You're normal."
    libc=/lib/libc.a
else
    ans=`loc libc.a blurfl/dyick $libpth`
    if test -f $ans; then
	echo "Your C library is in $ans, of all places."
	libc=ans
    else
	if test -f "$libc"; then
	    echo "Your C library is in $libc, like you said before."
	else
	    cat <<EOM
 
I can't seem to find your C library.  I've looked in the following places:

	$libpth

None of these seems to contain your C library.  What is the full name
EOM
	    dflt=None
	    $echo $n "of your C library? $c"
	    rp='C library full name?'
	    . myread
	    libc="$ans"
	fi
    fi
fi
echo " "
$echo $n "Extracting names from $libc for later perusal...$c"
if ar t $libc > libc.list; then
    echo "done"
else
    echo " "
    echo "The archiver doesn't think $libc is a reasonable library."
    echo "Trying nm instead..."
    if nm -g $libc > libc.list; then
	echo "Done.  Maybe this is Unicos, or an Apollo?"
    else
	echo "That didn't work either.  Giving up."
	exit 1
    fi
fi
rmlist="$rmlist libc.list"

: make some quick guesses about what we are up against
echo " "
$echo $n "Hmm...  $c"
if $contains SIGTSTP /usr/include/signal.h >/dev/null 2>&1 ; then
    echo "Looks kind of like a BSD system, but we'll see..."
    echo exit 0 >bsd
    echo exit 1 >usg
    echo exit 1 >v7
elif $contains fcntl libc.list >/dev/null 2>&1 ; then
    echo "Looks kind of like a USG system, but we'll see..."
    echo exit 1 >bsd
    echo exit 0 >usg
    echo exit 1 >v7
else
    echo "Looks kind of like a version 7 system, but we'll see..."
    echo exit 1 >bsd
    echo exit 1 >usg
    echo exit 0 >v7
fi
if $contains vmssystem libc.list >/dev/null 2>&1 ; then
    cat <<'EOI'
There is, however, a strange, musty smell in the air that reminds me of
something...hmm...yes...I've got it...there's a VMS nearby, or I'm a Blit.
EOI
    echo "exit 0" >eunice
    eunicefix=unixtovms
    d_eunice="$define"
: it so happens the Eunice I know will not run shell scripts in Unix format
else
    echo " "
    echo "Congratulations.  You aren't running Eunice."
    eunicefix=':'
    d_eunice="$undef"
    echo "exit 1" >eunice
fi
if test -f /xenix; then
    echo "Actually, this looks more like a XENIX system..."
    echo "exit 0" >xenix
else
    echo " "
    echo "It's not Xenix..."
    echo "exit 1" >xenix
fi
chmod 755 xenix
if test -f /venix; then
    echo "Actually, this looks more like a VENIX system..."
    echo "exit 0" >venix
else
    echo " "
    if xenix; then
	: null
    else
	echo "Nor is it Venix..."
    fi
    echo "exit 1" >venix
fi
chmod 755 bsd usg v7 eunice venix xenix
$eunicefix bsd usg v7 eunice venix xenix
rmlist="$rmlist bsd usg v7 eunice venix xenix"

: see if sh knows # comments
echo " "
echo "Checking your sh to see if it knows about # comments..."
if sh -c '#' >/dev/null 2>&1 ; then
    echo "Your sh handles # comments correctly."
    shsharp=true
    spitshell=cat
    echo " "
    echo "Okay, let's see if #! works on this system..."
    echo "#!/bin/echo hi" > try
    $eunicefix try
    chmod 755 try
    try > today
    if test -s today; then
	echo "It does."
	sharpbang='#!'
    else
	echo "#! /bin/echo hi" > try
	$eunicefix try
	chmod 755 try
	try > today
	if test -s today; then
	    echo "It does."
	    sharpbang='#! '
	else
	    echo "It doesn't."
	    sharpbang=': use '
	fi
    fi
else
    echo "Your sh doesn't grok # comments--I will strip them later on."
    shsharp=false
    echo "exec grep -v '^#'" >spitshell
    chmod 755 spitshell
    $eunicefix spitshell
    spitshell=`pwd`/spitshell
    echo "I presume that if # doesn't work, #! won't work either!"
    sharpbang=': use '
fi

: figure out how to guarantee sh startup
echo " "
echo "Checking out how to guarantee sh startup..."
startsh=$sharpbang'/bin/sh'
echo "Let's see if '$startsh' works..."
cat >try <<EOSS
$startsh
set abc
test "$?abc" != 1
EOSS

chmod 755 try
$eunicefix try
if try; then
    echo "Yup, it does."
else
    echo "Nope.  You may have to fix up the shell scripts to make sure sh runs them."
fi
rm -f try today

: find out how to find out full name
echo " "
case "$d_berknames" in
"$define")
    dflt=y;;
"$undef")
    dflt=n;;
*)
    if bsd; then
	dflt=y
    else
	dflt=n
    fi
    ;;
esac
echo "Does your /etc/passwd file keep full names in Berkeley/V7 format (name first"
$echo $n "thing after ':' in GCOS field)? [$dflt] $c"
rp="Berkeley/V7 format full name? [$dflt]"
. myread
case "$ans" in
  y*)
    d_passnames="$define"
    d_berknames="$define"
    d_usgnames="$undef"
    nametype=bsd
    ;;
  *)
    echo " "
    case "$d_usgnames" in
    "$define")
	dflt=y;;
    "$undef")
	dflt=n;;
    *)
	if usg; then
	    dflt=y
	else
	    dflt=n
	fi
	;;
    esac
    echo "Does your passwd file keep full names in USG format (name sandwiched"
    $echo $n "between a '-' and a '(')? [$dflt] $c"
    rp="USG format full name? [$dflt]"
    . myread
    case "$ans" in
      n*)
	echo "Full name will be taken from ~/.fullname"
	d_passnames="$undef"
	d_berknames="$undef"
	d_usgnames="$undef"
	nametype=other
	;;
      *)
	d_passnames="$define"
	d_berknames="$undef"
	d_usgnames="$define"
	nametype=usg
	;;
    esac
    ;;
esac

: see if we have to deal with yellow pages
if $test -d /usr/etc/yp; then
    if $contains '^\+:' /etc/passwd; then
	dflt=y
    else
	dflt=n
    fi
    rp="Are you getting the passwd file via yellow pages? [$dflt]"
    $echo $n "$rp $c"
    . myread
    case "$ans" in
    y*) passcat='ypcat passwd';;
    *) passcat='cat /etc/passwd';;
    esac
else
    passcat='cat /etc/passwd'
fi

: see if sprintf is declared as int or pointer to char
echo " "
if $contains 'char.*sprintf' /usr/include/stdio.h >/dev/null 2>&1 ; then
    echo "Your sprintf() returns (char*)."
    d_charsprf="$define"
else
    echo "Your sprintf() returns (int)."
    d_charsprf="$undef"
fi

: now get the host name
echo " "
echo "Figuring out host name..."
echo 'Maybe "hostname" will work...'
if ans=`sh -c hostname 2>&1` ; then
    hostname=$ans
    phostname=hostname
else
    echo 'Oh, dear.  Maybe "/etc/systemid" will work...'
    if ans=`sh -c '/etc/systemid' 2>&1` ; then
	hostname=$ans
	phostname='/etc/systemid'
	if xenix; then
	    echo "Whadyaknow.  Xenix always was a bit strange..."
	else
	    echo "What is a non-Xenix system doing with /etc/systemid?"
	fi
    else
	echo 'No, maybe "uuname -l" will work...'
	if ans=`sh -c 'uuname -l' 2>&1` ; then
	    hostname=$ans
	    phostname='uuname -l'
	else
	    echo 'Strange.  Maybe "uname -n" will work...'
	    if ans=`sh -c 'uname -n' 2>&1` ; then
		hostname=$ans
		phostname='uname -n'
	    else
		echo 'Oh well, maybe I can mine it out of whoami.h...'
		if ans=`sh -c $contains' sysname /usr/include/whoami.h' 2>&1` ; then
		    hostname=`echo "$ans" | $sed 's/^.*"\(.*\)"/\1/'`
		    phostname="sed -n -e '"'/sysname/s/^.*\"\\(.*\\)\"/\1/{'"' -e p -e q -e '}' </usr/include/whoami.h"
		else
		    case "$hostname" in
		    '') echo "Does this machine have an identity crisis or something?"
			phostname=''
			;;
		    *)  echo "Well, you said $hostname before...";;
		    esac
		fi
	    fi
	fi
    fi
fi
: you do not want to know about this
set $hostname
hostname=$1

: translate upper to lower if necessary
case "$hostname" in
    *[A-Z]*)
	hostname=`echo $hostname | tr '[A-Z]' '[a-z]'`
	echo "(Normalizing case in your host name)"
	;;
esac

: verify guess
if $test "$hostname" ; then
    dflt=y
    echo 'Your host name appears to be "'$hostname'".'
    $echo $n "Is this correct? [$dflt] $c"
    rp="Sitename is $hostname? [$dflt]"
    . myread
    case "$ans" in
      y*)  ;;
      *)      hostname='' ;;
    esac
fi

: bad guess or no guess
while $test "X$hostname" = X ; do
    dflt=''
    rp="Please type the (one word) name of your host:"
    $echo $n "$rp $c"
    . myread
    hostname="$ans"
done

echo " "
case "$hostname" in
*.*)
    dflt=`expr "X$hostname" : "X[^.]*\(\..*\)"`
    hostname=`expr "X$hostname" : "X\([^.]*\)\."`
    echo "(Trimming domain name from host name--host name is now $hostname)"
    ;;
*)
    dflt='.uucp'
    ;;
esac
rp="What is your domain name? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
'') ;;
.*) ;;
*) ans=".$ans";;
esac
mydomain="$ans"

: a little sanity check here
case "$phostname" in
'') ;;
*)  case `$phostname` in
    $hostname$mydomain|$hostname) ;;
    *)
	case "$phostname" in
	sed*)
	    echo "(That doesn't agree with your whoami.h file, by the way.)"
	    ;;
	*)
	    echo "(That doesn't agree with your $phostname command, by the way.)"
	    ;;
	esac
	phostname=''
	;;
    esac
    ;;
esac

: decide how portable to be
case "$d_portable" in
"$define") dflt=y;;
*)	dflt=n;;
esac
$cat <<'EOH'
 
I can set things up so that your shell scripts and binaries are more portable,
at what may be a noticable cost in performance.  In particular, if you
ask to be portable, the following happens:

     1) shell scripts will rely on the PATH variable rather than using
	the paths derived above.
     2) ~username interpretations will be done at run time rather than
	by Configure.
     3) the system name will be determined at run time, if at all possible.

EOH
rp="Do you expect to run these scripts and binaries on multiple machines? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
    y*) d_portable="$define"
	for file in $loclist; do
	    eval $file=$file
	done
	;;
    *)  d_portable="$undef" ;;
esac

: see if there is a whoami file
echo " "
if $test -r /usr/include/whoami.h ; then
    d_whoami="$define"
    echo "whoami.h found."
else
    d_whoami="$undef"
fi

: see how we will look up host name
echo " "
d_douname="$undef"
d_gethname="$undef"
d_phostname="$undef"

if xenix; then
    echo " "
    echo "(Assuming Xenix uname() is broken.)"
elif $contains gethostname libc.list >/dev/null 2>&1 ; then
    echo "gethostname() found."
    d_gethname="$define"
    ans=gethostname
elif $contains uname libc.list >/dev/null 2>&1 ; then
    echo "uname() found."
    d_douname="$define"
    ans=uname
fi

case "$d_douname$d_gethname" in
*define*)
    dflt=n
    cat <<EOM
 
Every now and then someone has a $ans() that lies about the hostname
but can't be fixed for political or economic reasons.  Would you like to
EOM
    rp="pretend $ans() isn't there and maybe compile in the hostname? [$dflt]"
    $echo $n "$rp $c"
    . myread
    case "$ans" in
    y*) d_douname="$undef" d_gethname="$undef"
	$echo $n "Okay... $c"
	;;
    esac
    ;;
esac

case "$d_douname$d_gethname" in
*define*) ;;
*)
    case "$phostname" in
      '') ;;
      *)
	$cat <<EOT
 
There is no gethostname() or uname() on this system.  You have two
possibilities at this point:

1)  You can have your host name ($hostname) compiled into $package, which
    lets $package start up faster, but makes your binaries non-portable, or
2)  you can have $package use a
	
	popen("$phostname","r")

    which will start slower but be more portable.

Option 1 will give you the option of using whoami.h if you have one.  If you
want option 2 but with a different command, you can edit config.sh at the
end of this shell script.

EOT
	case "$d_phostname" in
	"$define") dflt=n;;
	"$undef")  dflt=y;;
	'')
	    case "$d_portable" in
	    "$define") dflt=n ;;
	    *)      dflt=y ;;
	    esac
	    ;;
	esac
	rp="Do you want your host name compiled in? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	  n*) d_phostname="$define" ;;
	  *)  phostname=''
	      d_phostname="$undef"
	      ;;
	esac
	;;
    esac
    case "$phostname" in
      '')
	case "$d_whoami" in
	  "$define")
	    dflt=y
	    $cat <<EOM
 
No hostname function--you can either use the whoami.h file, which has this line:

	`grep sysname /usr/include/whoami.h`

or you can have the name we came up with earlier ($hostname) hardwired in.
EOM
	    rp="Use whoami.h to get hostname? [$dflt]"
	    $echo $n "$rp $c"
	    . myread
	    case "$ans" in
	    n*) d_whoami="$undef";;
	    esac
	    ;;
	  "$undef")
	    echo 'No hostname function and no whoami.h--hardwiring "'$hostname'".'
	    ;;
	esac
	;;
    esac
    ;;
esac

: see if this is an fcntl system
echo " "
if $test -r /usr/include/fcntl.h ; then
    d_fcntl="$define"
    echo "fcntl.h found."
else
    d_fcntl="$undef"
    echo "No fcntl.h found, but that's ok."
fi

: see if ftime exists
echo " "
if $contains ftime libc.list >/dev/null 2>&1; then
    echo 'ftime() found.'
    d_ftime="$define"
else
    echo 'ftime() not found--timing may be less accurate.'
    d_ftime="$undef"
fi

: see if there is a getpw
echo " "
if $contains getpw.o libc.list >/dev/null 2>&1 ; then
    echo "getpw() found."
    d_getpwent="$undef"
else
    echo "No getpw() found--will use getpwent() instead."
    d_getpwent="$define"
fi

: set up shell script to do ~ expansion
cat >filexp <<EOSS
$startsh
: expand filename
case "\$1" in
 ~/*|~)
    echo \$1 | $sed "s|~|\${HOME-\$LOGDIR}|"
    ;;
 ~*)
    if $test -f /bin/csh; then
	/bin/csh -f -c "glob \$1"
	echo ""
    else
	name=\`$expr x\$1 : '..\([^/]*\)'\`
	dir=\`$sed -n -e "/^\${name}:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\).*"'\$'"/\1/" -e p -e q -e '}' </etc/passwd\`
	if $test ! -d "\$dir"; then
	    me=\`basename \$0\`
	    echo "\$me: can't locate home directory for: \$name" >&2
	    exit 1
	fi
	case "\$1" in
	*/*)
	    echo \$dir/\`$expr x\$1 : '..[^/]*/\(.*\)'\`
	    ;;
	*)
	    echo \$dir
	    ;;
	esac
    fi
    ;;
*)
    echo \$1
    ;;
esac
EOSS
chmod 755 filexp
$eunicefix filexp
if test -d ../UU; then
	cp filexp ..
fi

: where do we get termlib routines from
echo " "
ans=`loc libcurses.a x $libpth`
case "$ans" in
/*)
    ar t $ans >grimble
    if $contains tputs.o grimble >/dev/null 2>&1; then
	termlib='-lcurses'
	d_havetlib="$define"
	echo "Terminfo library found."
    else
	ans=x
    fi
    ;;
esac
case "$ans" in
x)
    ans=`loc libtermlib.a x $libpth`
    case "$ans" in
    /usr/lib*|/lib*)
	termlib='-ltermlib'
	d_havetlib="$define"
	echo "Termlib library found."
	;;
    /*)
	termlib="$ans"
	d_havetlib="$define"
	echo "Termlib library found."
	;;
    *)
	ans=`loc libtermcap.a x $libpth`
	case "$ans" in
	/usr/lib*|/lib*)
	    termlib='-ltermcap'
	    d_havetlib="$define"
	    echo "Termcap library found."
	    ;;
	/*)
	    termlib="$ans"
	    d_havetlib="$define"
	    echo "Termcap library found."
	    ;;
	*)
	    case "$termlib" in
	    '')
		dflt=y
		rp="Your system appears to NOT have termlib-style routines.  Is this true? [$dflt]"
		$echo $n "$rp $c"
		. myread
		case "$ans" in
		    n*|f*) d_havetlib="$define"
			  echo "Then where are the termlib-style routines kept (specify either -llibname"
			  $echo $n " or full pathname (~name ok))? $c"
			  rp='Specify termlib:'
			  . myread
			  termlib=`filexp $ans`
			  ;;
		    *)    d_havetlib="$undef"
			  termlib=''
			  echo "You will have to play around with term.c then."
			  ;;
		esac
		echo " "
		;;
	    *)  echo "You said termlib was $termlib before."
		;;
	    esac
	    ;;
	esac
	;;
    esac
    ;;
esac

: index or strcpy
echo " "
dflt=y
if $contains index libc.list >/dev/null 2>&1 ; then
    echo "Your system appears to use index() and rindex() rather than strchr()"
    $echo $n "and strrchr().  Is this correct? [$dflt] $c"
    rp='index() rather than strchr()? [$dflt]'
    . myread
    case "$ans" in
	n*|f*) d_index="$define" ;;
	*)     d_index="$undef" ;;
    esac
else
    echo "Your system appears to use strchr() and strrchr() rather than index()"
    $echo $n "and rindex().  Is this correct? [$dflt] $c"
    rp='strchr() rather than index()? [$dflt]'
    . myread
    case "$ans" in
	n*|f*) d_index="$undef" ;;
	*)     d_index="$define" ;;
    esac
fi

: see if ioctl defs are in sgtty/termio or sys/ioctl
echo " "
if $test -r /usr/include/sys/ioctl.h ; then
    d_ioctl="$define"
    echo "sys/ioctl.h found."
else
    d_ioctl="$undef"
    echo "sys/ioctl.h not found, assuming ioctl args are defined in sgtty.h."
fi

: see if there are directory access routines out there
echo " "
if $test -r /usr/include/ndir.h && \
      ( $test -r /usr/lib/libndir.a || $test -r /usr/local/lib/libndir.a ); then
    echo "Ndir library found."
    if $test -r /usr/lib/libndir.a; then
	ndirlib='-lndir'
    else
	ndirlib="/usr/local/lib/libndir.a"
    fi
    d_libndir="$define"
    d_usendir="$undef"
    ndirc=''
    ndiro=''
else
    ndirlib=''
    d_libndir="$undef"
    if bsd && $contains readdir libc.list >/dev/null 2>&1 ; then
	echo "No ndir library found, but you have readdir() so we'll use that."
	d_usendir="$undef"
	ndirc=''
	ndiro=''
    else
	echo "No ndir library found--using ./ndir.c."
	d_usendir="$define"
	ndirc='ndir.c'
	ndiro='ndir.o'
    fi
fi

: see if we need -ljobs and if we have sigset, etc.
echo " "
if $test -r /usr/lib/libjobs.a || $test -r /usr/local/lib/libjobs.a ; then
    echo "Jobs library found."
    d_normsig="$undef"
    jobslib='-ljobs'
else
    if bsd; then
	echo "No jobs library found.  (I suppose this is at least 4.2...)"
    else
	echo "No jobs library found.  (That's okay, we all have our faults.)"
    fi
    d_normsig="$define"
    jobslib=''
fi

: see if rdchk exists
echo " "
if $contains rdchk libc.list >/dev/null 2>&1; then
    echo 'rdchk() found.'
    d_rdchk="$define"
else
    if v7; then
	echo "rdchk() not found--you'd better have FIONREAD or O_NDELAY."
    else
	echo 'rdchk() not found.'
    fi
    d_rdchk="$undef"
fi

: see how they want the scoreboard kept
case "$d_scorfl" in
"$define") dflt=y ;;
*) dflt=n ;;
esac
case "$nametype" in
other) d_scorfl="$undef" ;;
*)
    $cat <<'EOM'

The scoreboard can be kept with one score per login name, or one score
per full name.  If users can change their full name, or if there is
more than one person on your system with the same full name, you should
keep the score by login name (the full name is still printed).
EOM
    rp="Do you want the scoreboard kept by full name? [$dflt]"
    $echo $n "$rp $c"
    . myread
    case "$ans" in
    y*) d_scorfl="$define" ;;
    *)	d_scorfl="$undef" ;;
    esac
    ;;
esac

: check for signed chars
echo " "
echo "Checking to see if your C compiler can do signed chars..."
$cat >try.c <<'EOCP'
main()
{
	char c = 0;

	c--;
	exit(c >= 0);
}
EOCP
cc -o a.out try.c
if a.out; then
    d_sgndchr="$define"
    echo "It certainly can."
else
    d_sgndchr="$undef"
    echo "It can't.  I'll have to make some things type short."
fi
$rm -f try.* a.out

: see how we invoke the C preprocessor
echo " "
echo "Checking to see how your C preprocessor is invoked..."
cat <<'EOT' >testcpp.c
#define ABC abc
#define XYZ xyz
ABC.XYZ
EOT
echo 'Maybe "cc -E" will work...'
cc -E testcpp.c >testcpp.out 2>&1
if $contains 'abc.xyz' testcpp.out >/dev/null 2>&1 ; then
    echo "Yup, it does."
    cpp='cc -E'
else
    echo 'Nope...maybe "cc -P" will work...'
    cc -P testcpp.c >testcpp.out 2>&1
    if $contains 'abc.xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, that does."
	cpp='cc -P'
    else
	echo 'Nixed again...maybe "/lib/cpp" will work...'
	/lib/cpp testcpp.c >testcpp.out 2>&1
	if $contains 'abc.xyz' testcpp.out >/dev/null 2>&1 ; then
	    echo "Hooray, it works!  I was beginning to wonder."
	    cpp='/lib/cpp'
	else
	    echo 'Hmm...maybe you already told me...'
	    case "$cpp" in
	    '') ;;
	    *) $cpp testcpp.c >testcpp.out 2>&1;;
	    esac
	    if $contains 'abc.xyz' testcpp.out >/dev/null 2>&1 ; then
		echo "Hooray, you did!  I was beginning to wonder."
	    else
		dflt=blurfl
		$echo $n "Nope. I can't find a C preprocessor.  Name one: $c"
		rp='Name a C preprocessor:'
		. myread
		cpp="$ans"
		$cpp testcpp.c >testcpp.out 2>&1
		if $contains 'abc.xyz' testcpp.out >/dev/null 2>&1 ; then
		    echo "OK, that will do."
		else
		    echo "Sorry, I can't get that to work.  Go find one."
		    exit 1
		fi
	    fi
	fi
    fi
fi
rm -f testcpp.c testcpp.out

: get C preprocessor symbols handy
echo " "
echo $attrlist | $tr '[ ]' '[\012]' >Cppsym.know
$cat <<EOSS >Cppsym
$startsh
case "\$1" in
-l) list=true
    shift
    ;;
esac
unknown=''
case "\$list\$#" in
1|2)
    for sym do
	if $contains "^\$1$" Cppsym.true >/dev/null 2>&1; then
	    exit 0
	elif $contains "^\$1$" Cppsym.know >/dev/null 2>&1; then
		:
	else
	    unknown="\$unknown \$sym"
	fi
    done
    set X \$unknown
    shift
    ;;
esac
case \$# in
0) exit 1;;
esac
echo \$* | $tr '[ ]' '[\012]' | $sed -e 's/\(.*\)/\\
#ifdef \1\\
exit 0; _ _ _ _\1\\	 \1\\
#endif\\
/' >/tmp/Cppsym\$\$
echo exit 1 >>/tmp/Cppsym\$\$
$cpp /tmp/Cppsym\$\$ >/tmp/Cppsym2\$\$
case "\$list" in
true) awk '\$6 != "" {print substr(\$6,2,100)}' </tmp/Cppsym2\$\$ ;;
*)
    sh /tmp/Cppsym2\$\$
    status=\$?
    ;;
esac
$rm -f /tmp/Cppsym\$\$ /tmp/Cppsym2\$\$
exit \$status
EOSS
chmod 755 Cppsym
$eunicefix Cppsym
echo "Your C preprocessor defines the following symbols:"
Cppsym -l $attrlist >Cppsym.true
cat Cppsym.true
rmlist="$rmlist Cppsym Cppsym.know Cppsym.true"

: see if this is a termio system
echo " "
if Cppsym pyr && $test -r /usr/include/sgtty.h ; then
    d_termio="$undef"
    echo "sgtty.h found."
elif $test -r /usr/include/termio.h ; then
    d_termio="$define"
    echo "termio.h found."
elif $test -r /usr/include/sgtty.h ; then
    d_termio="$undef"
    echo "sgtty.h found."
else
    d_termio="$undef"
    echo "Neither termio.h nor sgtty.h found--you could have problems."
fi

: find out which shell people like to use most
case "$prefshell" in
'')
    if $test -f /bin/ksh; then
	dflt='/bin/ksh'
    elif $test -f /bin/csh; then
	dflt='/bin/csh'
    else
	dflt='/bin/sh'
    fi
    ;;
*)  dflt="$prefshell";;
esac
cont=true
while $test "$cont" ; do
    echo " "
    echo "Give the full path name of the shell most people like to use on your"
    $echo $n "system: [$dflt] $c"
    rp="Preferred shell: [$dflt]"
    . myread
    prefshell=$ans
    if test -f $ans; then
	cont=''
    else
	dflt=n
	rp="File $ans doesn't exist.  Use that name anyway? [$dflt]"
	$echo $n "$rp $c"
	. myread
	dflt=''
	case "$ans" in
	y*) cont='';;
	esac
    fi
done

: determine where private files go
case "$privlib" in
'')
    dflt=/usr/games/lib/$package
    ;;
*)  dflt="$privlib"
    ;;
esac
$cat <<EOM

The $package package has a some auxiliary files that should be put in a library
that is accessible by everyone.  Where do you want to put these private"
EOM
$echo $n "but accessible files? [$dflt] (~name ok) $c"
rp="Put private files where? [$dflt]"
. myread
privlib="$ans"
case "$privlib" in
  '') privlib=$dflt ;;
esac
case "$d_portable" in
"$undef")
    privlib=`filexp $privlib`
    ;;
esac

: check for size of random number generator
echo " "
case "$randbits" in
'')
    echo "Checking to see how many bits your rand function produces..."
    $cat >try.c <<'EOCP'
#include <stdio.h>
main()
{
    register int i;
    register long tmp;
    register long max;

    for (i=1000; i; i--) {
	tmp = (long)rand();
	if (tmp > max) max = tmp;
    }
    for (i=0; max; i++)
	max /= 2;
    printf("%d\n",i);
}
EOCP
    if cc try.c -o try >/dev/null 2>&1 ; then
	dflt=`try`
    else
	dflt='?'
	echo "(I can't seem to compile the test program...)"
    fi
    ;;
*)
    dflt="$randbits"
    ;;
esac
rp="How many bits does your rand() function produce? [$dflt]"
$echo $n "$rp $c"
. myread
randbits="$ans"
$rm -f try.c try

: see how many register declarations we want to use
case "$registers" in
'')
    if Cppsym vax; then
	dflt=6
    elif Cppsym sun mc68000; then
	dflt=10
    elif Cppsym pyr; then
	dflt=14
    elif Cppsym ns32000 ns16000; then
	dflt=5
    elif Cppsym $smallmach; then
	dflt=3
    else
	: if you have any other numbers for me, send them in
	dflt=6
    fi
    ;;
*)  dflt=$registers ;;
esac
cat <<EOM
 
Different C compilers on different machines pay attention to different
numbers of register declarations.  About how many register declarations in
EOM
$echo $n "each routine does your C compiler pay attention to? (OK to guess) [$dflt] $c"
rp="# register declarations used? [$dflt]"
. myread
registers=$ans
reg1=''
awk "END { for (i=1; i<=16; i++) printf \"reg%d=''\n\", i}" </dev/null >.foo
. .foo
awk "END { for (i=1; i<=$registers; i++) printf \"reg%d=register\n\", i}" \
	</dev/null >.foo
. .foo
rm -f .foo

: determine root id
echo " "
rootid=`$sed -e "/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*"'$'"/\1/" -e "q" -e "}" -e "d" </etc/passwd`
case "$rootid" in
  '') rootid=0 ;;
  *)  echo "Root uid = $rootid" ;;
esac

: check for void type
echo " "
$cat <<EOM
Checking to see how well your C compiler groks the void type...

  Support flag bits are:
    1: basic void declarations.
    2: arrays of pointers to functions returning void.
    4: operations between pointers to and addresses of void functions.

EOM
case "$voidflags" in
'')
    $cat >try.c <<'EOCP'
#if TRY & 1
void main() {
#else
main() {
#endif
	extern void *moo();
	void (*goo)();
#if TRY & 2
	void (*foo[10])();
#endif

#if TRY & 4
	if(goo == moo) {
		exit(0);
	}
#endif
	exit(0);
}
EOCP
    if cc -S -DTRY=7 try.c >.out 2>&1 ; then
	voidflags=7
	echo "It appears to support void fully."
	if $contains warning .out >/dev/null 2>&1; then
	    echo "However, you might get some warnings that look like this:"
	    $cat .out
	fi
    else
	echo "Hmm, you compiler has some difficulty with void.  Checking further..."
	if cc -S -DTRY=1 try.c >/dev/null 2>&1 ; then
	    echo "It supports 1..."
	    if cc -S -DTRY=3 try.c >/dev/null 2>&1 ; then
		voidflags=3
		echo "And it supports 2 but not 4."
	    else
		echo "It doesn't support 2..."
		if cc -S -DTRY=3 try.c >/dev/null 2>&1 ; then
		    voidflags=5
		    echo "But it supports 4."
		else
		    voidflags=1
		    echo "And it doesn't support 4."
		fi
	    fi
	else
	    echo "There is no support at all for void."
	    voidflags=0
	fi
    fi
esac
dflt="$voidflags";
rp="Your void support flags add up to what? [$dflt]"
$echo $n "$rp $c"
. myread
voidflags="$ans"
$rm -f try.* .out

: preserve RCS keywords in files with variable substitution, grrr
Log='$Log'
Header='$Header'

: determine where public executables go
case "$bin" in
'')
    dflt=`loc . /bin /usr/games /usr/local/bin /usr/lbin /usr/local /usr/bin`
    ;;
*)  dflt="$bin"
    ;;
esac
bin='blurfl/dyick'
while $test ! -d "$bin" ; do
    case "$bin" in
      blurfl*) ;;
      *) $echo "$bin does not appear to exist." ;;
    esac
    $echo " "
    rp="Where do you want to put the public executables? [$dflt]"
    $echo $n "$rp $c"
    . myread
    bin="$ans"
    bin=`filexp $bin`
    case "$bin" in
      '') bin=$dflt ;;
    esac
done

: determine where manual pages go
case "$mansrc" in
'')
    dflt=`loc . /usr/man/man1 /usr/man/mann /usr/man/local/man1 /usr/man/u_man/man1 /usr/man/man1`
    ;;
*)  dflt="$mansrc"
    ;;
esac
cont=true
while $test "$cont" ; do
    echo " "
    rp="Where do the manual pages (source) go? [$dflt]"
    $echo $n "$rp $c"
    . myread
    mansrc=`filexp "$ans"`
    if test -d $mansrc; then
	cont=''
    else
	dflt=n
	rp="Directory $mansrc doesn't exist.  Use that name anyway? [$dflt]"
	$echo $n "$rp $c"
	. myread
	dflt=''
	case "$ans" in
	y*) cont='';;
	esac
    fi
done

: see what memory models we can support
case "$models" in
'')
    if Cppsym pdp11; then
	dflt='unsplit split'
    else
	ans=`loc . X /lib/small /lib/large /usr/lib/small /usr/lib/large /lib/medium /usr/lib/medium /lib/huge`
	case "$ans" in
	X) dflt='none';;
	*)  if $test -d /lib/small || $test -d /usr/lib/small; then
		dflt='small'
	    else
		dflt=''
	    fi
	    if $test -d /lib/medium || $test -d /usr/lib/medium; then
		dflt="$dflt medium"
	    fi
	    if $test -d /lib/large || $test -d /usr/lib/large; then
		dflt="$dflt large"
	    fi
	    if $test -d /lib/huge || $test -d /usr/lib/huge; then
		dflt="$dflt huge"
	    fi
	esac
    fi
    ;;
*)  dflt="$models" ;;
esac
$cat <<EOM
 
Some systems have different model sizes.  On most systems they are called
small, medium, large, and huge.  On the PDP11 they are called unsplit and
split.  If your system doesn't support different memory models, say "none".
If you wish to force everything to one memory model, say "none" here and
put the appropriate flags later when it asks you for other cc and ld flags.
Venix systems may wish to put "none" and let the compiler figure things out.
(In the following question multiple model names should be space separated.)

EOM
rp="Which models are supported? [$dflt]"
$echo $n "$rp $c"
. myread
models="$ans"

case "$models" in
none)
    small=''
    medium=''
    large=''
    huge=''
    unsplit=''
    split=''
    ;;
*split)
    case "$split" in
    '') 
	if $contains '\\-i' /usr/man/man1/ld.1 >/dev/null 2>&1 || \
	   $contains '\\-i' /usr/man/man1/cc.1 >/dev/null 2>&1; then
	    dflt='-i'
	else
	    dflt='none'
	fi
	;;
    *) dflt="$split";;
    esac
    rp="What flag indicates separate I and D space? [$dflt]"
    $echo $n "$rp $c"
    . myread
    case "$ans" in
    none) ans='';;
    esac
    split="$ans"
    unsplit=''
    ;;
*large*|*small*|*medium*|*huge*)
    case "$model" in
    *large*)
	case "$large" in
	'') dflt='-Ml';;
	*) dflt="$large";;
	esac
	rp="What flag indicates large model? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	none) ans='';
	esac
	large="$ans"
	;;
    *) large='';;
    esac
    case "$model" in
    *huge*)
	case "$huge" in
	'') dflt='-Mh';;
	*) dflt="$huge";;
	esac
	rp="What flag indicates huge model? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	none) ans='';
	esac
	huge="$ans"
	;;
    *) huge="$large";;
    esac
    case "$model" in
    *medium*)
	case "$medium" in
	'') dflt='-Mm';;
	*) dflt="$medium";;
	esac
	rp="What flag indicates medium model? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	none) ans='';
	esac
	medium="$ans"
	;;
    *) medium="$large";;
    esac
    case "$model" in
    *small*)
	case "$small" in
	'') dflt='none';;
	*) dflt="$small";;
	esac
	rp="What flag indicates small model? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	none) ans='';
	esac
	small="$ans"
	;;
    *) small='';;
    esac
    ;;
*)
    echo "Unrecognized memory models--you may have to edit Makefile.SH"
    ;;
esac

case "$ccflags" in
'') dflt='none';;
*) dflt="$ccflags";;
esac
echo " "
rp="Any additional cc flags? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
none) ans='';
esac
ccflags="$ans"

case "$ldflags" in
'') if venix; then
	dflt='-i -z'
    else
	dflt='none'
    fi
    ;;
*) dflt="$ldflags";;
esac
echo " "
rp="Any additional ld flags? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
none) ans='';
esac
ldflags="$ans"

: see if we need a special compiler
echo " "
if usg; then
    case "$cc" in
    '')
	case "$Mcc" in
	/*) dflt='Mcc'
	    ;;
	*)
	    case "$large" in
	    -M*)
		dflt='cc'
		;;
	    *)
		if $contains '\-M' $mansrc/cc.1 >/dev/null 2>&1 ; then
		    dflt='cc -M'
		else
		    dflt='cc'
		fi
		;;
	    esac
	    ;;
	esac
	;;
    *)  dflt="$cc";;
    esac
    $cat <<'EOM'
 
On some systems the default C compiler will not resolve multiple global
references that happen to have the same name.  On some such systems the
"Mcc" command may be used to force these to be resolved.  On other systems
a "cc -M" command is required.  (Note that the -M flag on other systems
indicates a memory model to use!)  What command will force resolution on
EOM
    $echo $n "this system? [$dflt] $c"
    rp="Command to resolve multiple refs? [$dflt]"
    . myread
    cc="$ans"
else
    echo "Not a USG system--assuming cc can resolve multiple definitions."
    cc=cc
fi

: get uid to chown everything to
case "$chowner" in
'') dflt=daemon
    ;;
*)  dflt="$chowner"
    ;;
esac
$cat <<'EOM'
 
If you do a make install as the superuser, I can chown all the publicly
visible files to be owned by some particular user id.  Any setuid programs
in this package will run under this uid, and be able to access the files
that belong to this uid.  You should pick a uid that nobody can log into
that you don't trust to modify the programs or data files of this package.
You should probably not pick root if there are any setuid programs in this
package.  If you want to create a uid for this, do so before the make install.

EOM
rp="Uid to chown public files to? [$dflt]"
$echo $n "$rp $c"
. myread
chowner="$ans"
case "$chowner" in
'') chowner=$dflt ;;
esac

: see if we should include -lnm
echo " "
if $test -r /usr/lib/libnm.a || $test -r /usr/local/lib/libnm.a ; then
    echo "New math library found."
    libnm='-lnm'
else
    ans=`loc libtermlib.a x $libpth`
    case "$ans" in
    x)
	echo "No nm library found--the normal math library will have to do."
	libnm=''
	;;
    *)
	echo "New math library found in $ans."
	libnm="$ans"
	;;
    esac
fi

: Warnings
if v7; then
    cat <<'EOM'
 
NOTE: the V7 compiler may ignore some #undefs that $package uses.  If so,
you may get messages about redefining EXT.  Some V7 compilers also have
difficulties with #defines near buffer boundaries, so beware.  You may have
to play with the spacing in some .h files, believe it or not.
EOM
fi

: Warnings
if v7; then
    cat <<'EOM'

NOTE: many V7 systems do not have a way to do a non-blocking read.  If you
don't have any of FIONREAD, O_NDELAY, or rdchk(), the $package package
may not work as well as it might.  It might not work at all.
EOM
fi

$echo " "
$echo "End of configuration questions."
$echo " "

: create config.sh file
echo " "
if test -d ../UU; then
    cd ..
fi
echo "Creating config.sh..."
$spitshell <<EOT >config.sh
$startsh
# config.sh
# This file was produced by running the Configure script.

d_eunice='$d_eunice'
eunicefix='$eunicefix'
define='$define'
loclist='$loclist'
expr='$expr'
sed='$sed'
echo='$echo'
cat='$cat'
rm='$rm'
mv='$mv'
cp='$cp'
tail='$tail'
tr='$tr'
mkdir='$mkdir'
sort='$sort'
uniq='$uniq'
grep='$grep'
trylist='$trylist'
test='$test'
inews='$inews'
egrep='$egrep'
more='$more'
pg='$pg'
Mcc='$Mcc'
vi='$vi'
mailx='$mailx'
mail='$mail'
Log='$Log'
Header='$Header'
cc='$cc'
contains='$contains'
cpp='$cpp'
d_charsprf='$d_charsprf'
d_fcntl='$d_fcntl'
d_ftime='$d_ftime'
d_gethname='$d_gethname'
d_douname='$d_douname'
d_phostname='$d_phostname'
d_getpwent='$d_getpwent'
d_havetlib='$d_havetlib'
termlib='$termlib'
d_index='$d_index'
d_ioctl='$d_ioctl'
d_normsig='$d_normsig'
jobslib='$jobslib'
d_portable='$d_portable'
d_rdchk='$d_rdchk'
d_scorfl='$d_scorfl'
d_sgndchr='$d_sgndchr'
d_termio='$d_termio'
d_usendir='$d_usendir'
d_libndir='$d_libndir'
ndirc='$ndirc'
ndiro='$ndiro'
d_whoami='$d_whoami'
hostname='$hostname'
phostname='$phostname'
mydomain='$mydomain'
libc='$libc'
libnm='$libnm'
mansrc='$mansrc'
models='$models'
split='$split'
small='$small'
medium='$medium'
large='$large'
huge='$huge'
ccflags='$ccflags'
ldflags='$ldflags'
n='$n'
c='$c'
nametype='$nametype'
d_passnames='$d_passnames'
d_berknames='$d_berknames'
d_usgnames='$d_usgnames'
passcat='$passcat'
package='$package'
prefshell='$prefshell'
randbits='$randbits'
registers='$registers'
reg1='$reg1'
reg2='$reg2'
reg3='$reg3'
reg4='$reg4'
reg5='$reg5'
reg6='$reg6'
reg7='$reg7'
reg8='$reg8'
reg9='$reg9'
reg10='$reg10'
reg11='$reg11'
reg12='$reg12'
reg13='$reg13'
reg14='$reg14'
reg15='$reg15'
reg16='$reg16'
rootid='$rootid'
spitshell='$spitshell'
shsharp='$shsharp'
sharpbang='$sharpbang'
startsh='$startsh'
voidflags='$voidflags'
bin='$bin'
chowner='$chowner'
privlib='$privlib'
CONFIG=true
EOT
 
CONFIG=true

echo " "
dflt=''
echo "If you didn't make any mistakes, then just type a carriage return here."
rp="If you need to edit config.sh, do it as a shell escape here:"
$echo $n "$rp $c"
. UU/myread
case "$ans" in
'') ;;
*) : in case they cannot read
    eval $ans;;
esac

echo " "
echo "Doing variable substitutions on .SH files..."
set `$grep '\.SH' <MANIFEST | awk '{print $1}'`
for file in $*; do
    case "$file" in
    */*)
	dir=`$expr X$file : 'X\(.*\)/'`
	file=`$expr X$file : 'X.*/\(.*\)'`
	(cd $dir && . $file)
	;;
    *)
	. $file
	;;
    esac
done
if test -f config.h.SH; then
    if test ! -f config.h; then
	: oops, they left it out of MANIFEST, probably, so do it anyway.
	. config.h.SH
    fi
fi

if $contains '^depend:' Makefile >/dev/null 2>&1; then
    dflt=n
    $cat <<EOM

Now you need to generate make dependencies by running "make depend".
You might prefer to run it in background: "make depend > makedepend.out &"
It can take a while, so you might not want to run it right now.

EOM
    rp="Run make depend now? [$dflt]"
    $echo $n "$rp $c"
    . UU/myread
    case "$ans" in
    y*) make depend
	echo "Now you must run a make."
	;;
    *)  echo "You must run 'make depend' then 'make'."
	;;
    esac
elif test -f Makefile; then
    echo " "
    echo "Now you must run a make."
else
    echo "Done."
fi

$rm -f kit*isdone
cd UU && $rm -f $rmlist
: end of Configure
