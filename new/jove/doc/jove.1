.\" ditroff -ms
.de IQ
\\fI\\$1\\fP
..
.de dc
.NH 2
\\$1
.if '\\$2'(variable)' (variable)
.if !'\\$2'(variable)' (\\$2)
.LP
..
.nr LL 6.5i
.nr LT 6.5i
.EH 'USD:17-%''JOVE Manual for UNIX Users'
.OH 'JOVE Manual for UNIX Users''USD:17-%'
.LP
.TL
JOVE Manual for UNIX Users
.AU
Jonathan Payne
(revised for 4.3BSD by Doug Kingston and Mark Seiden)
.AI
.AB no
.AE
.NH 1
Introduction
.XS \n(PN
\*(SN Introduction
.XE
.LP
\s-2JOVE\s0*
.FS
*\s-2JOVE\s0 stands for Jonathan's Own Version of Emacs.
.FE
is an advanced, self-documenting, customizable real-time display editor.
It (and this tutorial introduction) are based on the original EMACS
editor and user manual written at M.I.T. by Richard Stallman+.
.FS
+Although \s-2JOVE\s0 is meant to be compatible with EMACS,
and indeed many of the basic commands are very similar,
there are some major differences between the two editors,
and you should not rely on their behaving identically.
.FE
.LP
\s-2JOVE\s0 is considered a
.I display 
editor because normally the text being
edited is visible on the screen and is updated automatically as you
type your commands.
.LP
It's considered a
.I real-time 
editor because the display is updated very
frequently, usually after each character or pair of characters you type.
This minimizes the amount of information you must keep in your
head as you edit.
.LP
\s-2JOVE\s0 is 
.I advanced 
because it provides facilities that go beyond
simple insertion and deletion:
filling of text;
automatic indentations of programs;
view more than one file at once;
and dealing in terms of characters, words, lines, sentences and paragraphs.
It is much easier
to type one command meaning "go to the end of the paragraph" than to
find the desired spot with repetition of simpler commands.
.LP
.I Self-documenting 
means that at almost any time you can easily
find out what a command does,
or to find all the commands that pertain to a topic.
.LP
.I Customizable
means that you can change the definition of \s-2JOVE\s0 commands
in little ways.
For example, you can rearrange the command set;
if you prefer to use arrow keys for the four basic cursor motion commands
(up, down, left and right), you can.
Another sort of customization is
writing new commands by combining built in commands.
.NH 1
The Organization of the Screen
.XS \n(PN
\*(SN The Organization of the Screen
.XE
.LP
\s-2JOVE\s0 divides the screen up into several sections.
The biggest of these sections is used to display the text you are editing.
The terminal's cursor shows the position of \fIpoint\fP,
the location at which editing takes place.
While the cursor appears to point \fIat\fP a character,
point should be thought of as between characters;
it points \fIbefore\fP the character that the cursor appears on top of.
Terminals have only one cursor,
and when output is in progress it must appear where the typing is being done.
This doesn't mean that point is moving;
it is only that \s-2JOVE\s0 has no way of
showing you the location of point except when the terminal is idle.
.LP
The lines of the screen are usually available for displaying text but
sometimes are pre-empted by typeout from certain commands (such as a
listing of all the editor commands).
Most of the time,
output from commands like these is only desired for a short period of time,
usually just long enough to glance at it.
When you have finished looking at the output,
you can type Space to make your text reappear.
(Usually a Space that you type inserts itself, but when there is typeout on
the screen, it does nothing but get rid of that).
Any other command executes normally,
.I after
redrawing your text.
.NH 2
The Message Line
.XS \n(PN 5n
\*(SN The Message Line
.XE
.LP
The bottom line on the screen, called the
\fImessage line\fP,
is reserved for printing messages and for accepting input from the user,
such as filenames or search strings.
When
\s-2JOVE\s0 
prompts for input,
the cursor will temporarily appear on the bottom line, waiting for you
to type a string.
When you have finished typing your input, you can
type a Return to send it to \s-2JOVE\s0.
If you change your mind about running the command that is waiting for input,
you can type Control-G to abort,
and you can continue with your editing.
.LP
When \s-2JOVE\s0 is prompting for a filename,
all the usual editing facilities can be used to fix typos and such;
in addition, \s-2JOVE\s0 has the following extra functions:
.IP "^N"
Insert the next filename from the argument list.
.IP "^P"
Insert the previous filename from the argument list.
.IP "^R"
Insert the full pathname of the file in the current buffer.
.LP
Sometimes you will see \fB--more--\fP on the message line.
This happens when typeout from a command is too long to fit in the screen.
It means that if you type a Space the next screenful of typeout will be
printed.
If you are not interested,
typing anything but a Space will cause the rest of the output to be discarded.
Typing C-G will discard the output and print \fIAborted\fP where the \fB--more--\fP was.
Typing any other command will discard the rest of the output and
also execute the command.
.LP
The message line and the list of filenames from the shell command that
invoked \s-2JOVE\s0 are kept in a special buffer called
\fIMinibuf\fP that can be edited like any other buffer.
.NH 2
The Mode Line
.XS \n(PN 5n
\*(SN The Mode Line
.XE
.LP
At the bottom of the screen, but above the message line, is the
\fImode line\fP.  The mode line format looks like this:
.DS I
\fBJOVE (major minor)   Buffer: bufr  "file" *\fP
.DE
\fImajor\fP is the name of the current \fImajor mode\fP.
At any time, \s-2JOVE\s0 can be in only one major mode at a time.
Currently there are only four major modes: \fIFundamental\fP,
\fIText\fP, \fILisp\fP and \fIC\fP.
.LP
\fIminor\fP is a list of the minor modes that are turned on.
\fBAbbrev\fP means that \fIWord Abbrev\fP mode is on;
\fBAI\fP means that \fIAuto Indent\fP mode is on;
\fBFill\fP means that \fIAuto Fill\fP mode is on;
\fBOvrWt\fP means that \fIOver Write\fP mode is on.
\fBDef\fP means that you are in the process of defining a keyboard macro.
This is not really a mode,
but it's useful to be reminded about it.
The meanings of these modes are described later in this document.
.LP
\fIbufr\fP is the name of the currently selected \fIbuffer\fP.
Each buffer has its own name and holds a file being edited;
this is how \s-2JOVE\s0 can hold several files at once.
But at any given time you are editing only one of them,
the \fIselected\fP buffer.
When we speak of what some command does to "the buffer",
we are talking about the currently selected buffer.
Multiple buffers makes it easy to switch around between several files,
and then it is very useful that
the mode line tells you which one you are editing at any time.  (You
will see later that it is possible to divide the
screen into multiple \fIwindows\fP, each showing a different buffer.  If you
do this, there is a mode line beneath each window.)
.LP
\fIfile\fP is the name of the file that you are editing.
This is the default filename for commands that expect a filename as input.
.LP
The asterisk at the end of the mode line means that there are changes in
the buffer that have not been saved in the file.
If the file has not been changed since it was read in or saved,
there is no asterisk.
.NH 1
Command Input Conventions
.XS \n(PN
\*(SN Command Input Conventions
.XE
.LP
.NH 2
Notational Conventions for ASCII Characters
.XS \n(PN 5n
\*(SN Notational Conventions for ASCII Characters
.XE
.LP
In this manual,
"Control" characters
(that is, characters that are typed with the Control key
and some other key at the same time)
are represented by "C-" followed by another character.
Thus,
C-A is the character you get when you type A with the Control key
(sometimes labeled CTRL) down.
Most control characters when present in the \s-2JOVE\s0
buffer are displayed with a caret; thus, ^A for C-A.
Rubout (or DEL) is displayed as ^?, escape as ^[.
.NH 2
Command and Filename Completion
.XS \n(PN 5n
\*(SN Command and Filename Completion
.XE
.LP
When you are typing the name of a \s-2JOVE\s0 command, you need type only
enough letters to make the name unambiguous.  At any point in the course of
typing the name, you can type question mark (?) to see a list of all the
commands whose names begin with the characters you've already typed; you can
type Space to have \s-2JOVE\s0 supply as many characters as it can; or you
can type Return to complete the command if there is only one possibility.
For example, if you have typed the letters "\fIau\fP" and you then type a
question mark, you will see the list
.DS I
   auto-execute-command
   auto-execute-macro
   auto-fill-mode
   auto-indent-mode
.DE
If you type a Return at this point, \s-2JOVE\s0 will complain by ringing
the bell, because the letters you've typed do not unambiguously specify a
single command.  But if you type Space, \s-2JOVE\s0 will supply the
characters "\fIto-\fP" because all commands that begin "\fIau\fP" also
begin "\fIauto-\fP".  You could then type the letter "\fIf\fP" followed
by either Space or Return, and \s-2JOVE\s0 would complete the entire
command.
.LP
Whenever \s-2JOVE\s0 is prompting you for a filename, say in the
\fIfind-file\fP command, you also need only type enough of the name to
make it unambiguous with respect to files that already exist.  In this
case, question mark and Space work just as they do in command completion,
but Return always accepts the name just as you've typed it, because you
might want to create a new file with a name similar to that of an
existing file.  The variable \fIbad-filename-extensions\fP contains a
list of words separated by spaces which are to be considered bad
filename extensions, and so will not be counted in filename completion.
The default is ".o" so if you have jove.c and jove.o in the same
directory, the filename completion will not complain of an ambiguity
because it will ignore jove.o.

.NH 1
Commands and Variables
.XS \n(PN
\*(SN Commands and Variables
.XE
.LP
\s-2JOVE\s0 is composed of \fIcommands\fP
which have long names such as
\fInext-line\fP.
Then \fIkeys\fP such as C-N are connected to
commands through the \fIcommand dispatch table\fP.
When we say that C-N moves the cursor down a line,
we are glossing over a distinction which is unimportant for ordinary use,
but essential for simple customization:
it is the command \fInext-line\fP which knows how to move a down line,
and C-N moves down a line because it is connected to that command.
The name for this connection is a \fIbinding\fP; we say that the key
C-N \fIis bound to\fP the command \fInext-line\fP.
.LP
Not all commands are bound to keys.  To invoke a command that isn't bound
to a key, you can type the sequence ESC X, which is bound to the command
\fIexecute-named-command\fP.  You will then be able to type the name of
whatever command you want to execute on the message line.
.LP
Sometimes the description of a command will say
"to change this, set the variable \fImumble\-foo\fP".
A variable is a name used to remember a value.
\s-2JOVE\s0 contains variables which are there so that you can change
them if you want to customize.
The variable's value is examined by some command,
and changing that value makes the command behave differently.
Until you are interesting in customizing \s-2JOVE\s0,
you can ignore this information.
.NH 2
Prefix Characters
.XS \n(PN 5n
\*(SN Prefix Characters
.XE
.LP
Because there are more command names than keys,
\s-2JOVE\s0 provides
\fIprefix characters\fP to increase the number of commands that can
be invoked quickly and easily.
When you type a prefix character \s-2JOVE\s0 will wait
for another character before deciding what to do.
If you wait more than a second or so,
\s-2JOVE\s0 will print the prefix character on the
message line as a reminder and leave the cursor down there until you type your next
character.
There are two prefix characters built into \s-2JOVE\s0:
Escape and Control-X.
How the next character is interpreted depends on which
prefix character you typed.
For example,
if you type Escape followed by B you'll run \fIbackward-word\fP,
but if you type Control-X followed by B you'll run \fIselect-buffer\fP.
Elsewhere in this manual, the Escape key is indicated as "ESC", which is
also what \s-2JOVE\s0 displays on the message line for Escape.
.NH 2
Help
.XS \n(PN
\*(SN Help
.XE
.LP
To get a list of keys and their associated commands,
you type ESC X \fIdescribe-bindings\fP.
If you want to describe a single key,
ESC X \fIdescribe-key\fP will work.  A description of an
individual command is available by using ESC X \fIdescribe-command\fP,
and descriptions of variables by using  ESC X \fIdescribe-variable\fP.
If you can't remember the name of the thing you want to know about,
ESC X \fIapropos\fP will tell you if a command or variable has a given
string in its name.  For example, ESC X \fIapropos describe\fP will
list the names of the four describe commands mentioned briefly in this
section.
.NH 1
Basic Editing Commands
.XS \n(PN
\*(SN Basic Editing Commands
.XE
.LP
.NH 2
Inserting Text
.XS \n(PN 5n
\*(SN Inserting Text
.XE
.LP
To insert printing characters into the text you are editing,
just type them.
All printing characters you type are inserted into the text at
the cursor (that is, at \fIpoint\fP),
and the cursor moves forward.
Any characters after the cursor move forward too.
If the text in the buffer is FOOBAR,
with the cursor before the B,
then if you type XX,
you get FOOXXBAR,
with the cursor still before the B.
.LP
To correct text you have just inserted,
you can use Rubout.
Rubout deletes the character \fIbefore\fP the cursor (not the one that the
cursor is on top of or under; that is the character \fIafter\fP the
cursor).
The cursor and all characters after it move backwards.
Therefore,
if you typing a printing character and then type Rubout,
they cancel out.
.LP
To end a line and start typing a new one,
type Return.
Return operates by inserting a \fIline-separator\fP,
so if you type Return in
the middle of a line,
you break the line in two.
Because a line-separator is just a single character,
you can type Rubout at the
beginning of a line to delete the line-separator and join it with the
preceding line.
.LP
As a special case, if you type Return at the end of a line and there are
two or more empty lines just below it, \s-2JOVE\s0 does not insert a
line-separator but instead merely moves to the next (empty) line.  This
behavior is convenient when you want to add several lines of text in the
middle of a buffer.  You can use the Control-O (\fInewline-and-backup\fP)
command to "open" several empty lines at once; then you can insert the new
text, filling up these empty lines.  The advantage is that \s-2JOVE\s0 does
not have to redraw the bottom part of the screen for each Return you type,
as it would ordinarily.  That "redisplay" can be both slow and distracting.
.LP
If you add too many characters to one line,
without breaking it with Return,
the line will grow too long to display on one screen line.
When this happens,
\s-2JOVE\s0 puts an "!" at the extreme right margin,
and doesn't bother to display the rest of the line unless the
cursor happens to be in it.
The "!" is not part of your text;
conversely,
even though you can't see the rest of your line,
it's still there,
and if you break the line,
the "!" will go away.
.LP
Direct insertion works for printing characters and space,
but other
characters act as editing commands and do not insert themselves.
If you need to insert a control character,
Escape,
or Rubout,
you must first \fIquote\fP it by typing the Control-Q command first.
.NH 2
Moving the Cursor
.XS \n(PN 5n
\*(SN Moving the Cursor
.XE
.LP
To do more than insert characters,
you have to know how to move the cursor.
Here are a few of the commands for doing that.
.IP "C-A" 15n
Move to the beginning of the line.
.IP "C-E" 15n
Move to the end of the line.
.IP "C-F" 15n
Move forward over one character.
.IP "C-B" 15n
Move backward over one character.
.IP "C-N" 15n
Move down one line,
vertically.
If you start in the middle of one line,
you end in the middle of the next.
.IP "C-P" 15n
Move up one line,
vertically.
.IP "ESC <" 15n
Move to the beginning of the entire buffer.
.IP "ESC >" 15n
Move to the end of the entire buffer.
.IP "ESC ," 15n
Move to the beginning of the visible window.
.IP "ESC ." 15n
Move to the end of the visible window.
.NH 2
Erasing Text
.XS \n(PN 5n
\*(SN Erasing Text
.XE
.LP
.IP "Rubout" 15n
Delete the character before the cursor.
.IP "C-D" 15n
Delete the character after the cursor.
.IP "C-K" 15n
Kill to the end of the line.
.LP
You already know about the Rubout command which deletes the character
before the cursor.
Another command,
Control-D,
deletes the character
after the cursor,
causing the rest of the text on the line to shift left.
If Control-D is typed at the end of a line,
that line and the next line are joined together.
.LP
To erase a larger amount of text,
use the Control-K command,
which kills a line at a time.
If Control-K is done at the beginning or
middle of a line,
it kills all the text up to the end of the line.
If Control-K is done at the end of a line,
it joins that line and the next line.
If Control-K is done twice, it kills the rest of the line and the line
separator also.
.NH 2
Files \(em Saving Your Work
.XS \n(PN 5n
\*(SN Files \(em Saving Your Work
.XE
.LP
The commands above are sufficient for creating text in the \s-2JOVE\s0 buffer.
The more advanced \s-2JOVE\s0 commands just make things easier.
But to keep any text permanently you must put it in a \fIfile\fP.
Files are the objects which
.UX
uses for storing data for a length of time.
To tell \s-2JOVE\s0 to read text into a file,
choose a filename,
such as \fIfoo.bar\fP,
and type C-X C-R \fIfoo.bar\fP<return>.
This reads the file \fIfoo.bar\fP so that its contents appear on the screen
for editing.
You can make changes,
and then save the file by typing C-X C-S (save-file).
This makes the changes permanent and actually changes the file \fIfoo.bar\fP.
Until then,
the changes are only inside \s-2JOVE\s0,
and the file \fIfoo.bar\fP is not really changed.
If the file \fIfoo.bar\fP doesn't exist,
and you want to create it,
read it as if it did exist.
When you save your text with C-X C-S the file will be created.
.NH 2
Exiting and Pausing \(em Leaving \s-2JOVE\s0
.XS \n(PN 5n
\*(SN Exiting and Pausing \(em Leaving \s-2JOVE\s0
.XE
.LP
The command C-X C-C (\fIexit-jove\fP) will terminate the \s-2JOVE\s0
session and return to the shell.  If there are modified but 
unsaved buffers, \s-2JOVE\s0 will ask you for confirmation, and you
can abort the command, look at what buffers are
modified but unsaved using C-X C-B (\fIlist-buffers\fP), save the 
valuable ones, and then exit.  If what you want to do, on the other hand,
is \fIpreserve\fP the editing session but return to the shell temporarily
you can (under Berkeley 
.UX
only) issue the command ESC S (\fIpause-jove\fP), do your 
.UX 
work within the c-shell, then return to \s-2JOVE\s0 using the 
\fIfg\fP command to resume editing at the point where you paused.
For this sort of situation you might consider using an \fIinteractive
shell\fP (that is, a shell in a \s-2JOVE\s0 window) which lets you use
editor commands to manipulate your 
.UX 
commands (and their output) while never leaving the editor.
(The interactive shell feature is described below.)
.NH 2
Giving Numeric Arguments to \s-2JOVE\s0 Commands
.XS \n(PN 5n
\*(SN Giving Numeric Arguments to \s-2JOVE\s0 Commands
.XE
.LP
Any \s-2JOVE\s0 command can be given a \fInumeric argument\fP.
Some commands interpret the argument as a repetition count.
For example,
giving an argument of ten to the C-F command (forward-character) moves forward
ten characters.
With these commands,
no argument is equivalent to an argument of 1.
.LP
Some commands use the value of the argument,
but do something peculiar (or nothing) when there is no argument.
For example,
ESC G (\fIgoto-line\fP) with an argument \fBn\fP
goes to the beginning of the \fBn\fP'th line.
But ESC G with no argument doesn't do anything.
Similarly, C-K with an argument kills that many lines, including their line
separators.  Without an argument, C-K when there is text on the line to the
right of
the cursor kills that text; when there is no text after the cursor, C-K
deletes the line separator.
.LP
The fundamental way of specifying an argument is to use ESC followed
by the digits of the argument, for example, ESC 123 ESC G to go to line
123. Negative arguments are allowed,
although not all of the commands know what to do with one.
.LP
Typing C-U means do the next command four times.
Two such C-U's multiply the next command by sixteen.
Thus,
C-U C-U C-F moves forward sixteen characters.
This is a good way to move forward quickly,
since it moves about 1/4 of a line on most terminals.
Other useful combinations are:
C-U C-U C-N (move down a good fraction of the screen),
C-U C-U C-O (make "a lot" of blank lines),
and C-U C-K (kill four lines \(em note that typing C-K four times
would kill 2 lines).
.LP
There are other,
terminal-dependent ways of specifying arguments.
They have the same effect but may be easier to type.
If your terminal
has a numeric keypad which sends something recognizably different from
the ordinary digits,
it is possible to program \s-2JOVE\s0 to to allow use of
the numeric keypad for specifying arguments.
.NH 2
The Mark and the Region
.XS \n(PN 5n
\*(SN The Mark and the Region
.XE
.LP
In general,
a command that processes an arbitrary part of the buffer
must know where to start and where to stop.
In \s-2JOVE\s0,
such commands usually operate on the text between point and \fIthe mark\fP.
This body of text is called \fIthe region\fP.
To specify a region,
you set point to one end of it and mark at the other.
It doesn't matter which one comes earlier in the text.
.IP "C-@" 15n
Set the mark where point is.
.IP "C-X C-X" 15n
Interchange mark and point.
.LP
For example,
if you wish to convert part of the buffer to all upper-case,
you can use the C-X C-U command,
which operates on the text in the region.
You can first go to the beginning of the text to be capitalized,
put the mark there, move to the end, and then type C-X C-U.
Or,
you can set the mark at the end of the text,
move to the beginning,
and then type C-X C-U.
C-X C-U runs the command \fIcase-region-upper\fP,
whose name signifies that the region,
or everything between point and mark,
is to be capitalized.
.LP
The way to set the mark is with the C-@ command or (on some
terminals) the C-Space command.
They set the mark where point is.
Then you can move point away,
leaving mark behind.  When the mark is set, "[Point pushed]" is printed on
the message line.
.LP
Since terminals have only one cursor,
there is no way for \s-2JOVE\s0 to show you where the mark is located.
You have to remember.
The usual solution to this problem is to set the mark and then use it soon,
before you forget where it is.
But you can see where the mark is with
the command C-X C-X which puts the mark where point was and point
where mark was.
The extent of the region is unchanged,
but the cursor and point are now at the previous location of the mark.
.NH 2
The Ring of Marks
.XS \n(PN 5n
\*(SN The Ring of Marks
.XE
.LP
Aside from delimiting the region,
the mark is also useful for remembering a spot that you may want to go back to.
To make this feature more useful,
\s-2JOVE\s0 remembers 16 previous locations of the mark.
Most commands that set the mark push the old mark onto this stack.
To return to a marked location, use C-U C-@.
This moves point to where the mark was,
and restores the mark from the stack of former marks.
So repeated use of this command moves point to all of the old
marks on the stack,
one by one.
Since the stack is actually a ring,
enough uses of C-U C-@ bring point back to where it was originally.
.LP
Some commands whose primary purpose is to move point a great distance
take advantage of the stack of marks to give you a way to undo the
command.
The best example is ESC <,
which moves to the beginning of the buffer.
If there are more than 22 lines between the beginning of
the buffer and point,
ESC < sets the mark first,
so that you can use C-U C-@ or C-X C-X to go back to where you were.
You can change the number of lines from 22 since it is kept in the variable \fImark-threshold\fP.
By setting it to 0,
you can make these commands always set the mark.
By setting it to a very large number you can prevent these commands from ever
setting the mark.
If a command decides to set the mark,
it prints the message \fI[Point pushed]\fP.
.NH 2
Killing and Moving Text
.XS \n(PN 5n
\*(SN Killing and Moving Text
.XE
.LP
The most common way of moving or copying text with \s-2JOVE\s0 is to kill it,
and get it back again in one or more places.
This is very safe
because the last several pieces of killed text are all remembered,
and it is versatile,
because the many commands for killing syntactic units
can also be used for moving those units.
There are also other ways of moving text for special purposes.
.NH 2
Deletion and Killing
.XS \n(PN 5n
\*(SN Deletion and Killing
.XE
.LP
Most commands which erase text from the buffer save it so that you can
get it back if you change your mind,
or move or copy it to other parts of the buffer.
These commands are known as \fIkill\fP commands.
The rest of the commands that erase text do not save it;
they are known as \fIdelete\fP commands.
The delete commands include C-D and Rubout,
which delete only one character at a time,
and those commands that delete only spaces or line separators.
Commands that can destroy significant amounts of nontrivial data generally kill.
A command's
name and description will use the words \fIkill\fP or \fIdelete\fP to
say which one it does.
.IP "C-D" 20n
Delete next character.
.IP "Rubout" 20n
Delete previous character.
.IP "ESC \e" 20n
Delete spaces and tabs around point.
.IP "C-X C-O" 20n
Delete blank lines around the current line.
.IP "C-K" 20n
Kill rest of line or one or more lines.
.IP "C-W" 20n
Kill region (from point to the mark).
.IP "ESC D" 20n
Kill word.
.IP "ESC Rubout" 20n
Kill word backwards.
.IP "ESC K" 20n
Kill to end of sentence.
.IP "C-X Rubout" 20n
Kill to beginning of sentence.
.NH 2
Deletion
.XS \n(PN 5n
\*(SN Deletion
.XE
.LP
The most basic delete commands are C-D and Rubout.
C-D deletes the character after the cursor,
the one the cursor is "on top of" or "underneath".
The cursor doesn't move.
Rubout deletes the character before the cursor,
and moves the cursor back.
Line separators act like normal characters when deleted.
Actually,
C-D and Rubout aren't always \fIdelete\fP commands;
if you give an argument,
they \fIkill\fP instead.
This prevents you from losing a great deal of text by typing a large
argument to a C-D or Rubout.
.LP
The other delete commands are those which delete only formatting
characters:
spaces,
tabs,
and line separators.
ESC \e (\fIdelete-white-space\fP)
deletes all the spaces and tab characters before and after point.
C-X C-O (\fIdelete-blank-lines\fP) deletes all blank lines after the current line,
and if the current line is blank deletes all the blank
lines preceding the current line as well
(leaving one blank line, the current line).
.NH 2
Killing by Lines
.XS \n(PN 5n
\*(SN Killing by Lines
.XE
.LP
The simplest kill command is the C-K command.
If issued at the beginning of a line,
it kills all the text on the line,
leaving it blank.
If given on a line containing only white space (blanks and tabs)
the line disappears.
As a consequence,
if you go to the front of a non-blank line and type two C-K's,
the line disappears completely.
.LP
More generally,
C-K kills from point up to the end of the line,
unless it is at the end of a line.
In that case,
it kills the line separator following the line,
thus merging the next line into the current one.
Invisible spaces and tabs at the end of the line are ignored when
deciding which case applies,
so if point appears to be at the end of the line,
you can be sure the line separator will be killed.
.LP
C-K with an argument of zero kills all the text before
point on the current line.
.NH 2
Other Kill Commands
.XS \n(PN 5n
\*(SN Other Kill Commands
.XE
.LP
A kill command which is very general is C-W (\fIkill-region\fP),
which kills everything between point and the mark.*
.FS
*Often users switch this binding from C-W to C-X C-K because it is too
easy to hit C-W accidentally.
.FE
With this command,
you can kill and save contiguous characters,
if you first set the mark at one end of them and go to the other end.
.LP
Other syntactic units can be killed, too;
words,
with ESC Rubout and ESC D;
and, sentences,
with ESC K and C-X Rubout.
.NH 2
Un-killing
.XS \n(PN 5n
\*(SN Un-killing (Yanking)
.XE
.LP
Un-killing (yanking) is getting back text which was killed.
The usual way to
move or copy text is to kill it and then un-kill it one or more times.
.IP "C-Y" 10n
Yank (re-insert) last killed text.
.IP "ESC Y" 10n
Replace re-inserted killed text with the previously killed text.
.IP "ESC W" 10n
Save region as last killed text without killing.
.LP
Killed text is pushed onto a \fIring buffer\fP called the \fIkill
ring\fP that remembers the last 10 blocks of text that were killed.
(Why it is called a ring buffer will be explained below).
The command C-Y (\fIyank\fP) reinserts the text of the most recent kill.
It leaves the cursor at the end of the text,
and puts the mark at the beginning.
Thus,
a single C-Y undoes the C-W.
.LP
If you wish to copy a block of text,
you might want to use ESC W (\fIcopy-region\fP),
which copies the region into the kill ring without removing it from the buffer.
This is approximately equivalent to C-W followed by C-Y,
except that ESC W does not mark the buffer as
"changed" and does not cause the screen to be rewritten.
.LP
There is only one kill ring shared among all the buffers.
After visiting a new file,
whatever was last killed in the previous file is still on top of the kill ring.
This is important for moving text between files.
.NH 2
Appending Kills
.XS \n(PN 5n
\*(SN Appending Kills
.XE
.LP
Normally,
each kill command pushes a new block onto the kill ring.
However,
two or more kill commands immediately in a row (without any other
intervening commands) combine their text into a
single entry on the ring,
so that a single C-Y command gets it all back as it was before it was killed.
This means that you don't have to kill all the text in one command;
you can keep killing line after line,
or word after word,
until you have killed it all,
and you can still get it all back at once.
.LP
Commands that kill forward from 
.I point 
add onto the end of the previous
killed text.
Commands that kill backward from 
.I point
add onto the beginning.
This way,
any sequence of mixed forward and backward kill
commands puts all the killed text into one entry without needing rearrangement.
.NH 2
Un-killing Earlier Kills
.XS \n(PN 5n
\*(SN Un-killing Earlier Kills
.XE
.LP
To recover killed text that is no longer the most recent kill,
you need the ESC Y (\fIyank-pop\fP) command.
The ESC Y command can be used
only after a C-Y (yank) command or another ESC Y.
It takes the un-killed
text inserted by the C-Y and replaces it with the text from an earlier
kill.
So,
to recover the text of the next-to-the-last kill,
you first use C-Y to recover the last kill,
and then discard it by use of ESC Y to move back to the previous kill.
.LP
You can think of all the last few kills as living on a ring.
After a C-Y command,
the text at the front of the ring is also present in the buffer.
ESC Y "rotates" the ring bringing the previous string of text to the front
and this text replaces the other text in the buffer as well.
Enough ESC Y commands can rotate any part of the ring to the front,
so you can get at any killed text so long as it is recent enough
to be still in the ring.
Eventually the ring rotates all the way
around and the most recently killed text comes to the front
(and into the buffer) again.
ESC Y with a negative argument rotates the ring backwards.
.LP
When the text you are looking for is brought into the buffer,
you can stop doing ESC Y's and the text will stay there.
It's really just a copy of what's at the front of the ring,
so editing it does not change what's in the ring.
And the ring,
once rotated,
stays rotated,
so that doing another C-Y gets another copy of what you rotated to the
front with ESC Y.
.LP
If you change your
mind about un-killing,
C-W gets rid of the un-killed text, even
after any number of ESC Y's.
.NH 1
Searching
.XS \n(PN
\*(SN Searching
.XE
.LP
The search commands are useful for finding and moving to arbitrary
positions in the buffer in one swift motion.
For example,
if you just ran the spell program on a paper
and you want to correct some word,
you can use the search commands to move directly to that word.  There are
two flavors of search: \fIstring search\fP and \fIincremental search\fP.
The former is the default flavor\(emif you want to use incremental search
you must rearrange the key bindings (see below).
.NH 2
Conventional Search
.XS \n(PN 5n
\*(SN Conventional Search
.XE
.LP
.IP "C-S" 15n
Search forward.
.IP "C-R" 15n
Search backward.
.LP
To search for the string "FOO" you type "C-S FOO<return>".
If \s-2JOVE\s0 finds
FOO it moves point to the end of it; otherwise \s-2JOVE\s0 prints an error
message and leaves point unchanged.
C-S searches forward from point
so only occurrences of FOO after point are found.
To search in the other direction use C-R.
It is exactly the same as C-S except it searches in the opposite direction,
and if it finds the string,
it leaves point at the beginning of it,
not at the end as in C-S.
.LP
While \s-2JOVE\s0 is searching it prints the search string on the message line.
This is so you know what \s-2JOVE\s0 is doing.
When the system is heavily loaded and
editing in exceptionally large buffers,
searches can take several (sometimes many) seconds.
.LP
\s-2JOVE\s0 remembers the last search string you used,
so if you want to search for the same string you can type "C-S <return>".
If you mistyped the last search string,
you can type C-S followed by C-R.
C-R,
as usual,
inserts the default search string into the minibuffer,
and then you can fix it up.
.NH 2
Incremental Search
.XS \n(PN 5n
\*(SN Incremental Search
.XE
.LP
This search command is unusual in that is is \fIincremental\fP;
it begins to search before you have typed the complete search string.
As you type in the search string,
\s-2JOVE\s0 shows you where it would be found.
When you have typed enough characters to identify the place you want,
you can stop.
Depending on what you will do next,
you may or may not need to terminate the search explicitly with a Return first.
.LP
The command to search is C-S (\fIi-search-forward\fP).
C-S reads in characters and positions the cursor at the first
occurrence of the characters that you have typed so far.
If you type C-S and then F,
the cursor moves in the text just after the next "F".
Type an "O",
and see the cursor move to after the next "FO".
After another "O",
the cursor is after the next "FOO".
At the same time,
the "FOO" has echoed on the message line.
.LP
If you type a mistaken character,
you can rub it out.
After the FOO,
typing a Rubout makes the "O" disappear from the message line,
leaving only "FO".
The cursor moves back in the buffer to the "FO".
Rubbing out the "O" and "F" moves the cursor back to where you
started the search.
.LP
When you are satisfied with the place you have reached,
you can type a Return,
which stops searching,
leaving the cursor where the search brought it.
Also,
any command not specially meaningful in searches stops
the searching and is then executed.
Thus,
typing C-A would exit the search and then move to the beginning of the line.
Return is necessary only if the next character you want to type is a printing
character,
Rubout,
Return,
or another search command,
since those are the characters that have special meanings inside the search.
.LP
Sometimes you search for "FOO" and find it,
but not the one you hoped to find.
Perhaps there is a second FOO that you forgot about,
after the one you just found.
Then type another C-S and the cursor will find the next FOO.
This can be done any number of times.
If you overshoot,
you can return to previous finds by rubbing out the C-S's.
.LP
After you exit a search,
you can search for the same string again by typing just C-S C-S:
one C-S command to start the search and then
another C-S to mean "search again for the same string".
.LP
If your string is not found at all,
the message line says "Failing I-search".
The cursor is after the place where \s-2JOVE\s0 found as much of
your string as it could.
Thus,
if you search for FOOT and there is no FOOT,
you might see the cursor after the FOO in FOOL.
At this point there are several things you can do.
If your string was mistyped,
you can rub some of it out and correct it.
If you like the place you have found,
you can type Return or some other \s-2JOVE\s0 command
to "accept what the search offered".
Or you can type C-G,
which undoes the search altogether and positions you back where you started
the search.
.LP
You can also type C-R at any time to start searching backwards.
If a search fails because the place you started was too late in the file,
you should do this.
Repeated C-R's keep looking backward for more occurrences of the last search string.
A C-S starts going forward again.
C-R's can be rubbed out just like anything else.
.NH 2
Searching with Regular Expressions
.XS \n(PN 5n
\*(SN Searching with Regular Expressions
.XE
.LP
In addition to the searching facilities described above,
\s-2JOVE\s0
can search for patterns using regular expressions.
The handling of regular expressions in \s-2JOVE\s0 is like that of \fIed(1)\fP
or \fIvi(1)\fP, but with some notable additions.
The extra metacharacters understood by \s-2JOVE\s0 are \e<,
\e>,
\e\|| and \e\|{.
The first two of these match the beginnings and endings of words;
Thus the search pattern,
"\|\e<Exec" would match all words beginning with the letters "Exec".
.LP
An \e\|| signals the beginning of an alternative \(em that is, the
pattern "foo\e\||bar" would match either "foo" or "bar".  The "curly
brace" is a way of introducing several sub-alternatives into a pattern.
It parallels the [] construct of regular expressions, except it specifies
a list of alternative words instead of just alternative characters.  So
the pattern "foo\e\|{bar,baz\e\|}bie" matches "foobarbie" or "foobazbie".
.LP
\s-2JOVE\s0 only regards metacharacters as special if the variable
\fImatch-regular-expressions\fP is set to "on".
The ability to have \s-2JOVE\s0 ignore these characters is useful if
you're editing a document about patterns and regular expressions or
when a novice is learning \s-2JOVE\s0.
.LP
Another variable that affects searching is \fIcase-ignore-search\fP.  If
this variable is set to "on" then upper case and lower case letters are
considered equal.
.NH 1
Replacement Commands
.XS \n(PN
\*(SN Replacement Commands
.XE
.LP
Global search-and-replace operations are not needed as often in \s-2JOVE\s0
as they are in other editors,
but they are available.
In addition to
the simple Replace operation which is like that found in most editors,
there is a Query Replace operation which asks,
for each occurrence of the pattern,
whether to replace it.
.NH 2
Global replacement
.XS \n(PN 5n
\*(SN Global Replacement
.XE
.LP
To replace every occurrence of FOO after point with BAR,
you can do, e.g., "ESC R FOO<return>BAR" as the \fIreplace-string\fP command
is bound to the ESC R.
Replacement takes place only between point and the end of the buffer
so if you want to cover the whole buffer you must go to the beginning first.
.NH 2
Query Replace
.XS \n(PN 5n
\*(SN Query Replace
.XE
.LP
If you want to change only some of the occurrences of FOO,
not all,
then the global \fIreplace-string\fP is inappropriate;
Instead,
use, e.g., "ESC Q FOO<return>BAR", to run the command \fIquery-replace-string\fP.
This displays each occurrence of FOO and waits for you to say whether
to replace it with a BAR.
The things you can type when you are shown an occurrence of FOO are:
.IP "Space" 15n
to replace the FOO.
.IP "Rubout" 15n
to skip to the next FOO without replacing this one.
.IP "Return" 15n
to stop without doing any more replacements.
.IP "Period" 15n
to replace this FOO and then stop.
.IP "! or P" 15n
to replace all remaining FOO's without asking.
.IP "C-R or R" 15n
to enter a recursive editing level,
in case the FOO needs to be edited rather than just replaced with a BAR.
When you are done,
exit the recursive editing level with C-X C-C and the next FOO will
be displayed.
.IP "C-W" 15n
to delete the FOO, and then start editing the buffer.
When you are finished editing whatever is to replace the FOO,
exit the recursive editing level with C-X C-C
and the next FOO will be displayed.
.IP "U" 15n
move to the last replacement and undo it.
.LP
Another alternative is using \fIreplace-in-region\fP which is just like
\fIreplace-string\fP except it searches only within the region.
.LP
