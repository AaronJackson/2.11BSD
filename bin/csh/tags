COMMAND	sh.file.c	31
Dfix	sh.dol.c	/^Dfix(t)$/
Dfix1	sh.dol.c	/^Dfix1(cp)$/
Dfix2	sh.dol.c	/^Dfix2(v)$/
DgetC	sh.dol.c	/^DgetC(flag)$/
Dgetdol	sh.dol.c	/^Dgetdol()$/
Dredc	sh.dol.c	/^Dredc()$/
Dtestq	sh.dol.c	/^Dtestq(c)$/
Dword	sh.dol.c	/^Dword()$/
FREE_ITEMS	sh.file.c	/^#define FREE_ITEMS(items) { \\$/
Gcat	sh.glob.c	/^Gcat(s1, s2)$/
Gmatch	sh.glob.c	/^Gmatch(s, p)$/
Msh	sh.c	/^main(c, av)$/
Perror	sh.err.c	/^Perror(s)$/
XFREE	sh.h	/^#define XFREE(cp) { \\$/
acollect	sh.glob.c	/^acollect(as)$/
addla	sh.lex.c	/^addla(cp)$/
addpath	sh.glob.c	/^addpath(c)$/
adrof	sh.h	/^#define adrof(v)	adrof1(v, &shvhed)$/
adrof1	sh.set.c	/^adrof1(name, v)$/
alias	sh.parse.c	/^alias(lex)$/
alnum	sh.char.h	/^#define alnum(c)	(digit(c) || letter(c))$/
amatch	sh.glob.c	/^amatch(s, p)$/
any	sh.misc.c	/^any(c, s)$/
asx	sh.set.c	/^asx(vp, subscr, p)$/
asyn0	sh.parse.c	/^asyn0(p1, p2)$/
asyn3	sh.parse.c	/^asyn3(p1, p2)$/
asyntax	sh.parse.c	/^asyntax(p1, p2)$/
back_to_col_1	sh.file.c	/^back_to_col_1()$/
backeval	sh.glob.c	/^backeval(cp, literal)$/
balance	sh.set.c	/^balance(p, f, d)$/
beep	sh.file.c	/^beep()$/
bferr	sh.err.c	/^bferr(cp)$/
bfree	sh.lex.c	/^bfree()$/
bgetc	sh.lex.c	/^bgetc()$/
bis	sh.exec.h	/^#define bis(h, b)	((h)[(b) >> 3] |= 1 << ((b) & 7)/
bit	sh.exec.h	/^#define bit(h, b)	((h)[(b) >> 3] & 1 << ((b) & 7))/
blkcat	sh.misc.c	/^blkcat(up, vp)$/
blkcpy	sh.misc.c	/^blkcpy(oav, bv)$/
blkend	sh.misc.c	/^blkend(up)$/
blkfree	sh.misc.c	/^blkfree(av0)$/
blklen	sh.misc.c	/^blklen(av)$/
blkpr	sh.misc.c	/^blkpr(av)$/
blkspl	sh.misc.c	/^blkspl(up, vp)$/
bool	sh.h	29
bseek	sh.lex.c	/^bseek(l)$/
btell	sh.h	/^#define btell()	fseekp$/
btoeof	sh.lex.c	/^btoeof()$/
calloc	sh.misc.c	/^calloc(i, j)$/
catn	sh.file.c	/^catn(des, src, count)$/
chkclob	sh.sem.c	/^chkclob(cp)$/
closem	sh.misc.c	/^closem()$/
cmap	sh.char.h	/^#define cmap(c, bits)	(_cmap[(unsigned char)(c)] &/
collect	sh.glob.c	/^collect(as)$/
copy	sh.local.h	/^#define	copy(to, from, size)	bcopy(from, to, size)/
copyblk	sh.misc.c	/^copyblk(v)$/
copylex	sh.lex.c	/^copylex(hp, fp)$/
copyn	sh.file.c	/^copyn(des, src, count)$/
dcanon	sh.dir.c	/^dcanon(cp, p)$/
dcopy	sh.misc.c	/^dcopy(i, j)$/
dfind	sh.dir.c	/^dfind(cp)$/
dfollow	sh.dir.c	/^dfollow(cp)$/
dfree	sh.dir.c	/^dfree(dp)$/
digit	sh.char.h	/^#define digit(c)	cmap(c, _DIG)$/
dinit	sh.dir.c	/^dinit(hp)$/
dmove	sh.misc.c	/^dmove(i, j)$/
dnewcwd	sh.dir.c	/^dnewcwd(dp)$/
doagain	sh.func.c	/^doagain()$/
doalias	sh.func.c	/^doalias(v)$/
dobackp	sh.glob.c	/^dobackp(cp, literal)$/
dobg	sh.proc.c	/^dobg(v)$/
dobg1	sh.proc.c	/^dobg1(v)$/
dobreak	sh.func.c	/^dobreak()$/
dochngd	sh.dir.c	/^dochngd(v)$/
docontin	sh.func.c	/^docontin()$/
dodirs	sh.dir.c	/^dodirs(v)$/
doecho	sh.func.c	/^doecho(v)$/
doelse	sh.func.c	/^doelse()$/
doend	sh.func.c	/^doend()$/
doeval	sh.func.c	/^doeval(v)$/
doexec	sh.exec.c	/^doexec(t)$/
doexit	sh.func.c	/^doexit(v)$/
dofg	sh.proc.c	/^dofg(v)$/
dofg1	sh.proc.c	/^dofg1(v)$/
doforeach	sh.func.c	/^doforeach(v)$/
doglob	sh.func.c	/^doglob(v)$/
dogoto	sh.func.c	/^dogoto(v)$/
dohash	sh.exec.c	/^dohash()$/
dohist	sh.hist.c	/^dohist(vp)$/
dohist1	sh.hist.c	/^dohist1(hp, np, rflg, hflg)$/
doif	sh.func.c	/^doif(v, kp)$/
doio	sh.sem.c	/^doio(t, pipein, pipeout)$/
dojobs	sh.proc.c	/^dojobs(v)$/
dokill	sh.proc.c	/^dokill(v)$/
dolabel	sh.func.c	/^dolabel()$/
dolet	sh.set.c	/^dolet(v)$/
dolimit	sh.func.c	/^dolimit(v)$/
dologin	sh.func.c	/^dologin(v)$/
dologout	sh.func.c	/^dologout()$/
domod	sh.lex.c	/^domod(cp, type)$/
done	sh.c	/^done(i)$/
donefds	sh.misc.c	/^donefds()$/
donewgrp	sh.func.c	/^donewgrp(v)$/
donice	sh.time.c	/^donice(v)$/
donohup	sh.func.c	/^donohup()$/
donotify	sh.proc.c	/^donotify(v)$/
doonintr	sh.func.c	/^doonintr(v)$/
dopopd	sh.dir.c	/^dopopd(v)$/
dopushd	sh.dir.c	/^dopushd(v)$/
dorepeat	sh.func.c	/^dorepeat(v, kp)$/
doset	sh.set.c	/^doset(v)$/
dosetenv	sh.func.c	/^dosetenv(v)$/
dosource	sh.c	/^dosource(t)$/
dostop	sh.proc.c	/^dostop(v)$/
dosub	sh.lex.c	/^dosub(sc, en, global)$/
dosuspend	sh.func.c	/^dosuspend()$/
doswbrk	sh.func.c	/^doswbrk()$/
doswitch	sh.func.c	/^doswitch(v)$/
dotime	sh.time.c	/^dotime()$/
doumask	sh.func.c	/^doumask(v)$/
dounhash	sh.exec.c	/^dounhash()$/
dounlimit	sh.func.c	/^dounlimit(v)$/
dounsetenv	sh.func.c	/^dounsetenv(v)$/
dowait	sh.proc.c	/^dowait()$/
dowhich	sh.exec2.c	/^dowhich(v, c)$/
dowhile	sh.func.c	/^dowhile(v)$/
dozip	sh.func.c	/^dozip()$/
draino	sh.print.c	/^draino()$/
dtildepr	sh.dir.c	/^dtildepr(home, dir)$/
echo	sh.func.c	/^echo(sep, v)$/
egetn	sh.exp.c	/^egetn(cp)$/
enthist	sh.hist.c	/^enthist(event, lp, docopy)$/
eq	sh.h	/^#define	eq(a, b)	(strcmp(a, b) == 0)$/
error	sh.err.c	/^error(s, arg)$/
etracc	sh.exp.c	/^etracc(str, cp, vp)$/
etraci	sh.exp.c	/^etraci(str, i, vp)$/
evalav	sh.exp.c	/^evalav(v)$/
execash	sh.exec.c	/^execash(t, kp)$/
execbrc	sh.glob.c	/^execbrc(p, s)$/
executable	sh.exec2.c	/^executable(dir, name, dir_ok)$/
execute	sh.sem.c	/^execute(t, wanttty, pipein, pipeout)$/
exit	sh.local.h	/^#define	exit(n)	done(n)$/
exitstat	sh.c	/^exitstat()$/
exp	sh.exp.c	/^exp(vp)$/
exp0	sh.exp.c	/^exp0(vp, ignore)$/
exp1	sh.exp.c	/^exp1(vp, ignore)$/
exp2	sh.exp.c	/^exp2(vp, ignore)$/
exp2a	sh.exp.c	/^exp2a(vp, ignore)$/
exp2b	sh.exp.c	/^exp2b(vp, ignore)$/
exp2c	sh.exp.c	/^exp2c(vp, ignore)$/
exp3	sh.exp.c	/^exp3(vp, ignore)$/
exp3a	sh.exp.c	/^exp3a(vp, ignore)$/
exp4	sh.exp.c	/^exp4(vp, ignore)$/
exp5	sh.exp.c	/^exp5(vp, ignore)$/
exp6	sh.exp.c	/^exp6(vp, ignore)$/
expand	sh.glob.c	/^expand(as)$/
exportpath	sh.set.c	/^exportpath(val)$/
extract_dir_and_name	sh.file.c	/^extract_dir_and_name(path, dir, name)$/
filetype	sh.file.c	/^filetype(dir, file)$/
findev	sh.lex.c	/^findev(cp, anyarg)$/
findlim	sh.func.c	/^findlim(cp)$/
flush	sh.print.c	/^flush()$/
free_items	sh.file.c	/^free_items(items)$/
freelex	sh.lex.c	/^freelex(vp)$/
freenod	sh.parse.c	/^freenod(p1, p2)$/
freesyn	sh.parse.c	/^freesyn(t)$/
func	sh.func.c	/^func(t, bp)$/
getC	sh.lex.c	/^#define getC(f)		((getCtmp = peekc) ? (peekc = 0, /
getC1	sh.lex.c	/^getC1(flag)$/
getdol	sh.lex.c	/^getdol()$/
getentry	sh.file.c	/^getentry(dir_fd, looking_for_lognames)$/
getexcl	sh.lex.c	/^getexcl(sc)$/
getexit	sh.h	/^#define	getexit(a)	copy((char *)(a), (char *)resla/
gethdir	sh.c	/^gethdir(home)$/
gethent	sh.lex.c	/^gethent(sc)$/
getinx	sh.set.c	/^getinx(cp, ip)$/
getn	sh.set.c	/^getn(cp)$/
getsel	sh.lex.c	/^getsel(al, ar, dol)$/
getsub	sh.lex.c	/^getsub(en)$/
getval	sh.func.c	/^getval(lp, v)$/
getvx	sh.set.c	/^getvx(vp, subscr)$/
getword	sh.func.c	/^getword(wp)$/
ginit	sh.glob.c	/^ginit(agargv)$/
glob	sh.glob.c	/^glob(v)$/
globone	sh.glob.c	/^globone(str)$/
goodbye	sh.c	/^goodbye()$/
hash	sh.exec.h	/^#define hash(a, b)	((a) * HSHMUL + (b) & HSHMASK)$/
hashname	sh.exec.c	/^hashname(cp)$/
hashstat	sh.exec.c	/^hashstat()$/
heredoc	sh.dol.c	/^heredoc(term)$/
hfree	sh.hist.c	/^hfree(hp)$/
if	sh.set.c	/^	} else if (sizeof (int) == 4 && n == -2147483648)/
ignored	sh.file.c	/^ignored(entry)$/
importpath	sh.c	/^importpath(cp)$/
initdesc	sh.c	/^initdesc()$/
is_prefix	sh.file.c	/^is_prefix(check, template)$/
is_suffix	sh.file.c	/^is_suffix(check, template)$/
isa	sh.exp.c	/^isa(cp, what)$/
isbfunc	sh.func.c	/^isbfunc(t)$/
iscommand	sh.exec2.c	/^iscommand(name)$/
isglob	sh.char.h	/^#define isglob(c)	cmap(c, _GLOB)$/
islogin	sh.func.c	/^islogin()$/
ismeta	sh.char.h	/^#define ismeta(c)	cmap(c, _META)$/
isspace	sh.char.h	/^#define isspace(c)	cmap(c, _SP)$/
isspnl	sh.char.h	/^#define isspnl(c)	cmap(c, _SP|_NL)$/
lastchr	sh.misc.c	/^lastchr(cp)$/
letter	sh.char.h	/^#define letter(c)	cmap(c, _LET)$/
lex	sh.lex.c	/^lex(hp)$/
limtail	sh.func.c	/^limtail(cp, str0)$/
lshift	sh.misc.c	/^lshift(v, c)$/
madrof	sh.set.c	/^madrof(pat, vp)$/
mailchk	sh.c	/^mailchk()$/
match	sh.glob.c	/^match(s, p)$/
matchdir	sh.glob.c	/^matchdir(pattern)$/
matchs	sh.lex.c	/^matchs(str, pat)$/
mypipe	sh.sem.c	/^mypipe(pv)$/
noev	sh.lex.c	/^noev(cp)$/
nomem	sh.misc.c	/^nomem(i)$/
number	sh.misc.c	/^number(cp)$/
okpcntl	sh.proc.c	/^okpcntl()$/
onlyread	sh.misc.c	/^onlyread(cp)$/
operate	sh.set.c	/^operate(op, vp, p)$/
p2dig	sh.print.c	/^p2dig(i)$/
padd	sh.proc.c	/^padd(t)$/
pads	sh.proc.c	/^pads(cp)$/
palloc	sh.proc.c	/^palloc(pid, t)$/
panystop	sh.proc.c	/^panystop(neednl)$/
pchild	sh.proc.c	/^pchild()$/
pclrcurr	sh.proc.c	/^pclrcurr(pp)$/
pdeltat	sh.time.c	/^pdeltat(t1, t0)$/
pendjob	sh.proc.c	/^pendjob()$/
pexerr	sh.exec.c	/^pexerr()$/
pfind	sh.proc.c	/^pfind(cp)$/
pflush	sh.proc.c	/^pflush(pp)$/
pflushall	sh.proc.c	/^pflushall()$/
pfork	sh.proc.c	/^pfork(t, wanttty)$/
pgetcurr	sh.proc.c	/^pgetcurr(pp)$/
phist	sh.hist.c	/^phist(hp, hflg)$/
phup	sh.c	/^phup()$/
pintr	sh.c	/^pintr()$/
pintr1	sh.c	/^pintr1(wantnl)$/
pjwait	sh.proc.c	/^pjwait(pp)$/
pkill	sh.proc.c	/^pkill(v, signum)$/
plim	sh.func.c	/^plim(lp, hard)$/
plist	sh.set.c	/^plist(p)$/
pnote	sh.proc.c	/^pnote()$/
pprint	sh.proc.c	/^pprint(pp, flag)$/
prefix	sh.misc.c	/^prefix(sub, str)$/
preread	sh.func.c	/^preread()$/
prestjob	sh.proc.c	/^prestjob()$/
print_by_column	sh.file.c	/^print_by_column(dir, items, count)$/
print_recognized_stuff	sh.file.c	/^print_recognized_stuff(recognized_part)$/
printprompt	sh.c	/^printprompt()$/
prlex	sh.lex.c	/^prlex(sp0)$/
process	sh.c	/^process(catch)$/
prusage	sh.time.c	/^prusage(r0, r1, e, b)$/
prvars	sh.func.c	/^prvars()$/
psave	sh.glob.c	/^psave(c)$/
psavejob	sh.proc.c	/^psavejob()$/
psecs	sh.print.c	/^psecs(l)$/
pstart	sh.proc.c	/^pstart(pp, foregnd)$/
ptprint	sh.proc.c	/^ptprint(tp)$/
pushback	sh.file.c	/^pushback(string)$/
putchar	sh.print.c	/^putchar(c)$/
putn	sh.set.c	/^putn(n)$/
putn1	sh.set.c	/^putn1(n)$/
pwait	sh.proc.c	/^pwait()$/
pword	sh.glob.c	/^pword()$/
readc	sh.lex.c	/^readc(wanteof)$/
rechist	sh.c	/^rechist()$/
recognize	sh.file.c	/^recognize(extended_name, entry, name_length, numit/
reexecute	sh.func.c	/^reexecute(kp)$/
renum	sh.misc.c	/^renum(i, j)$/
reset	sh.h	/^#define	reset()		longjmp(reslab, 0)$/
resexit	sh.h	/^#define	resexit(a)	copy((char *)reslab, ((char *)(/
return	sh.set.c	/^	return (savestr(number));$/
retype	sh.file.c	/^retype()$/
rleft	sh.set.c	/^#define rleft(p) (\\$/
rright	sh.set.c	/^#define rright(p) (\\$/
rscan	sh.glob.c	/^rscan(t, f)$/
ruadd	sh.time.c	/^ruadd(ru, ru2)$/
saveblk	sh.misc.c	/^saveblk(v)$/
savehist	sh.hist.c	/^savehist(sp)$/
savestr	sh.misc.c	/^savestr(s)$/
search	sh.file.c	/^search(word, command, max_word_length)$/
set	sh.set.c	/^set(var, val)$/
set1	sh.set.c	/^set1(var, vec, head)$/
setDolp	sh.dol.c	/^setDolp(cp)$/
setNS	sh.set.c	/^setNS(cp)$/
setenv	sh.func.c	/^setenv(name, val)$/
seterr	sh.err.c	/^seterr(s)$/
seterr2	sh.err.c	/^seterr2(cp, dp)$/
seterrc	sh.err.c	/^seterrc(cp, d)$/
setexclp	sh.lex.c	/^setexclp(cp)$/
setexit	sh.h	/^#define	setexit()	((void) setjmp(reslab))$/
setlim	sh.func.c	/^setlim(lp, hard, limit)$/
setname	sh.h	/^#define	setname(a)	(bname = (a))$/
setq	sh.set.c	/^setq(name, vec, p)$/
settell	sh.lex.c	/^settell()$/
settimes	sh.time.c	/^settimes()$/
setup_tty	sh.file.c	/^setup_tty(on)$/
shift	sh.set.c	/^shift(v)$/
sort	sh.glob.c	/^#define sort()	qsort((char *)sortbas, &gargv[gargc/
sortscmp	sh.glob.c	/^sortscmp(a1, a2)$/
srccat	sh.c	/^srccat(cp, dp)$/
srchx	sh.func.c	/^srchx(cp)$/
srcunit	sh.c	/^srcunit(unit, onlyown, hflg)$/
strend	sh.misc.c	/^strend(cp)$/
strip	sh.misc.c	/^strip(cp)$/
strspl	sh.misc.c	/^strspl(cp, dp)$/
subword	sh.lex.c	/^subword(cp, type, adid)$/
syn0	sh.parse.c	/^syn0(p1, p2, flags)$/
syn1	sh.parse.c	/^syn1(p1, p2, flags)$/
syn1a	sh.parse.c	/^syn1a(p1, p2, flags)$/
syn1b	sh.parse.c	/^syn1b(p1, p2, flags)$/
syn2	sh.parse.c	/^syn2(p1, p2, flags)$/
syn3	sh.parse.c	/^syn3(p1, p2, flags)$/
syntax	sh.parse.c	/^syntax(p1, p2, flags)$/
tellmewhat	sh.exec2.c	/^tellmewhat(lex)$/
tenex	sh.file.c	/^tenex(inputline, inputline_size)$/
texec	sh.exec.c	/^texec(f, t)$/
tglob	sh.glob.c	/^tglob(t)$/
tilde	sh.file.c	/^tilde(new, old)$/
toend	sh.func.c	/^toend()$/
trim	sh.glob.c	/^trim(t)$/
tvadd	sh.time.c	/^tvadd(tsum, t0)$/
tvsub	sh.time.c	/^tvsub(tdiff, t1, t0)$/
udvar	sh.misc.c	/^udvar(name)$/
unDgetC	sh.dol.c	/^#define	unDgetC(c)	Dpeekc = c$/
unDredc	sh.dol.c	/^unDredc(c)$/
unalias	sh.func.c	/^unalias(v)$/
ungetC	sh.lex.c	/^#define	ungetC(c)	peekc = c$/
ungetD	sh.lex.c	/^#define	ungetD(c)	peekd = c$/
unreadc	sh.lex.c	/^unreadc(c)$/
unset	sh.set.c	/^unset(v)$/
unset1	sh.set.c	/^unset1(v, head)$/
unsetenv	sh.func.c	/^unsetenv(name)$/
unsetv	sh.set.c	/^unsetv(var)$/
unsetv1	sh.set.c	/^unsetv1(p)$/
untty	sh.c	/^untty()$/
value	sh.h	/^#define value(v)	value1(v, &shvhed)$/
value1	sh.set.c	/^value1(var, head)$/
vffree	sh.sem.c	/^vffree()$/
wfree	sh.func.c	/^wfree()$/
word	sh.lex.c	/^word()$/
xalloc	sh.h	/^#define xalloc(i) ((alloctmp = malloc(i)) ? alloct/
xechoit	sh.exec.c	/^xechoit(t)$/
xfree	sh.misc.c	/^xfree(cp)$/
xset	sh.set.c	/^xset(cp, vp)$/
